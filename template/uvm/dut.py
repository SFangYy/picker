# File       : __init__.py
# Author     : automatically generated by picker
# Date       : {{date_now}}
# Description: Python package initialization for {{package_name}}
# Version    : {{version}}

"""
{{package_name}} Python Package

UVM transaction-based communication package.
"""

__version__ = "{{version}}"

{% if __SIMULATOR__ == "vcs" %}
# ============================================================================
# Dynamic VCS Database Handling (Universal Path Support)
# ============================================================================
import os
import sys
import atexit

# VCS engine expects the database (.daidir) to be in the current working directory.
# To allow running from any directory, we dynamically create a symlink to the real database.
package_dir = os.path.dirname(os.path.abspath(__file__))
so_name = '_tlm_pbsb.so'
daidir_name = so_name + '.daidir'
real_daidir_path = os.path.join(package_dir, daidir_name)

# Create a temporary symlink if we are not in the package directory and the link doesn't exist
if os.path.exists(real_daidir_path) and not os.path.exists(daidir_name):
    try:
        os.symlink(real_daidir_path, daidir_name)
        # Clean up the symlink on exit to keep the user's directory clean
        atexit.register(lambda: os.path.exists(daidir_name) and os.path.islink(daidir_name) and os.remove(daidir_name))
    except Exception as e:
        print(f"Warning: Failed to create symlink for VCS database: {e}", file=sys.stderr)
        print(f"Simulation might fail if it cannot find '{daidir_name}'.", file=sys.stderr)

# ============================================================================
# Auto-configure LD_PRELOAD to handle Static TLS limitations
# ============================================================================
# The extension library consumes significant Static TLS, which is exhausted 
# during normal runtime. It MUST be loaded at process startup.
# We detect this and restart the process with LD_PRELOAD injected.
if '_LD_PRELOAD_HANDLED' not in os.environ:
    so_path = os.path.join(package_dir, so_name)
    if os.path.exists(so_path):
        env = os.environ.copy()
        current_preload = env.get('LD_PRELOAD', '')
        env['LD_PRELOAD'] = f"{so_path}:{current_preload}" if current_preload else so_path
        env['_LD_PRELOAD_HANDLED'] = '1'
        
        # Use sys.orig_argv (Python 3.10+) to ensure -m pytest etc. are preserved
        args = getattr(sys, 'orig_argv', [sys.executable] + sys.argv)
        
        # Restart the process with the new environment
        try:
            # Small delay or flush to ensure logs are visible before exec
            sys.stdout.flush()
            sys.stderr.flush()
            os.execve(sys.executable, args, env)
        except Exception as e:
            print(f"Error: Failed to relaunch with LD_PRELOAD: {e}", file=sys.stderr)
            sys.exit(1)
{% endif %}

# ============================================================================
# Common imports for both DUT and Agent modes
# ============================================================================
import ctypes
# Set dlopen flags to use RTLD_GLOBAL for symbol visibility
sys.setdlopenflags(sys.getdlopenflags() | ctypes.RTLD_GLOBAL)

try:
    from . import tlm_pbsb as u
    from . import xspcomm as xsp
    from .xagent import Agent, BaseTransaction{% for trans in transactions %}, {{trans.name}}{% endfor %}
except ImportError as e:
    import sys
    print(f"Error: Failed to import required modules: {e}", file=sys.stderr)
    print("Make sure tlm_pbsb, xspcomm, and xagent modules are properly installed.", file=sys.stderr)
    raise

{% if generate_dut -%}
# ============================================================================
# DUT Mode: Integrated __init__.py with DUT implementation
# ============================================================================

from typing import Optional, Callable, Dict, Type, List
import struct
import subprocess

# ==================== DUT Implementation ====================

class _PinWrapper:
    """Wrapper to provide dut.pin.value access instead of dut.pin.xdata.value"""
    def __init__(self, xpin: xsp.XPin):
        self._xpin = xpin
        self.dirty = False

    @property
    def value(self):
        return self._xpin.xdata.value

    @value.setter
    def value(self, val):
        if self._xpin.xdata.value != val:
            self._xpin.xdata.value = val
            self.dirty = True

    @property
    def xpin(self):
        return self._xpin

    @property
    def xdata(self):
        return self._xpin.xdata

    @property
    def event(self):
        return self._xpin.event  

class DUT{{package_name}}:
    """
    DUT abstraction for {{package_name}} with pin-level interface.

    Pins:
    {% for data in variables -%}
    - {{data.name}}: {{data.bit_count}}-bit signal
    {% endfor -%}
    Example:
        >>> dut = DUT{{package_name}}()
        {%- for data in variables -%}
        {%- if loop.index == 1 %}
        >>> dut.{{data.name}}.value = 10
        {%- endif -%}
        {%- endfor %}
        >>> dut.Step(1)
    """

    def __init__(self, **kwargs):
        """Initialize DUT with Agent and xspcomm infrastructure."""
        self._event = xsp.Event()
        self._is_first_step = True
        self._xports: Dict[str, xsp.XPort] = {}
        self._user_callback: Optional[Callable[['DUT{{package_name}}'], None]] = None
        self._xpins = {}
        self._callback_pending = False

        # Monitor feedback extra cycles (configurable)
        self._monitor_extra_cycles: int = kwargs.get('monitor_extra_cycles', 1)

        # Initialize XPins and XPorts per transaction
        {% for trans in transactions -%}
        # Transaction: {{trans.name}}
        self._xports['{{trans.name}}'] = xsp.XPort()
        {% for data in trans.variables -%}
        self._xpins['{{data.name}}'] = xsp.XPin(xsp.XData({{data.bit_count}}), self._event)
        self._xpins['{{data.name}}'].xdata.AsImmWrite()
        self._xports['{{trans.name}}'].Add("{{data.name}}", self._xpins['{{data.name}}'].xdata)
        {% endfor -%}

        {% endfor -%}
        # Create pin accessors
        {% for data in variables -%}
        self.{{data.name}} = _PinWrapper(self._xpins['{{data.name}}'])
        {% endfor -%}

        # Monitor callback
        def _monitor_callback(trans_type: str, trans_obj):
            """Internal callback for monitor updates."""
            try:
                # Update pins from received transaction
                {% for trans in transactions %}
                if trans_type == '{{trans.name}}':   
                    {% for data in trans.variables -%}
                    self._xpins['{{data.name}}'].xdata.value = trans_obj.{{data.name}}.value
                    {% endfor -%}                            
                {% endfor %}
                self._callback_pending = True
            except Exception as e:
                print(f"Monitor callback error: {e}")

        # Initialize unified Agent (disable auto_register, we'll register manually)
        self.agent = Agent(monitor_callback=_monitor_callback, auto_register=False)

        # Register all transaction types
        {% for trans in transactions -%}
        send_port = kwargs.get('send_port_{{trans.name}}', '{{trans.name}}')
        receive_port = kwargs.get('receive_port_{{trans.name}}', '{{trans.name}}')
        self.agent.register_transaction({{trans.name}}, send_port=send_port, receive_port=receive_port)
        {% endfor %}
        self.dut = self

        class _Clock:
            def __init__(self, agent): self.agent = agent
            @property
            def clk(self): return self.agent._cycle_count
        self.xclock = _Clock(self.agent)

    def Step(self, cycles: int = 1):
        """
        Advance simulation by specified cycles.
        1. Send current pin values as transactions (only if dirty)
        2. Run simulation
        3. Update pins from monitor
        4. Execute clock callbacks (after monitor update)
        """
        for i in range(cycles):
            # Create and drive transactions
            {% for trans in transactions -%}
            # Check if {{trans.name}} is dirty
            _is_{{trans.name}}_dirty = self._is_first_step or any([
                {% for data in trans.variables -%}
                self.{{data.name}}.dirty,
                {% endfor -%}
            ])

            if _is_{{trans.name}}_dirty:
                tr = {{trans.name}}()
                {% for data in trans.variables -%}
                tr.{{data.name}}.value = self._xpins['{{data.name}}'].xdata.value
                {% endfor -%}
                self.agent.drive(tr)
                # Reset dirty flags for pins in this transaction
                {% for data in trans.variables -%}
                self.{{data.name}}.dirty = False
                {% endfor -%}
            {% endfor -%}
            
            self._is_first_step = False
            self._callback_pending = False

            # Run 1 cycle WITHOUT triggering callbacks yet
            self.agent.run(1, count_cycles=False)

            # Run extra cycles for monitor feedback without counting
            self.agent.run(self._monitor_extra_cycles, count_cycles=False)

            # Wait for monitor callback (without counting cycles)
            wait_count = 0
            while not self._callback_pending and wait_count < 10:
                self.agent.run(1, count_cycles=False)
                wait_count += 1

            # Trigger user callback
            if self._callback_pending and self._user_callback:
                self._user_callback(self)
                self._callback_pending = False

            # NOW increment cycle and trigger callbacks after monitor update
            if self.agent._clock_enabled:
                self.agent._cycle_count += 1
                for callback in self.agent._posedge_callbacks:
                    callback(self.agent._cycle_count)

    def SetUpdateCallback(self, callback: Optional[Callable[['DUT{{package_name}}'], None]]):
        """Register callback after monitor updates."""
        self._user_callback = callback

    def SetZero(self):
        """Set all pins to zero."""
        {% for data in variables -%}
        self._xpins['{{data.name}}'].xdata.value = 0
        {% endfor %}

    def InitClock(self, clock_pin: Optional[str] = None, domain: str = "default", frequency: Optional[float] = None):
        """
        Initialize clock tracking and management.

        Args:
            clock_pin: Name of the clock pin (optional, for validation only)
                      If None, clock tracking works without pin validation
            domain: Clock domain name for documentation (default: "default")
            frequency: Optional clock frequency in Hz

        Example:
            dut.InitClock()  # Simple cycle counting
            dut.InitClock("clk")  # Validate clock pin exists
            dut.InitClock("clk", domain="sys_clk", frequency=100e6)
        """
        if clock_pin is not None and clock_pin not in self._xpins:
            raise ValueError(f"Clock pin '{clock_pin}' not found. Available pins: {list(self._xpins.keys())}")

        # Delegate to Agent
        self.agent.InitClock(domain=domain, frequency=frequency)

    def StepRis(self, callback: Callable[[int], None]):
        """
        Register callback for clock rising edge.

        Args:
            callback: Function that takes cycle number as argument

        Example:
            def on_posedge(cycle):
                print(f"Cycle {cycle}: value = {dut.pin.value}")

            dut.StepRis(on_posedge)
        """
        # Delegate to Agent
        self.agent.StepRis(callback)

    def StepFal(self, callback: Callable[[int], None]):
        """
        Register callback for clock falling edge.

        Args:
            callback: Function that takes cycle number as argument

        Note: Currently falling edge callbacks are not triggered in Pack mode
              as the clock is managed by SystemVerilog testbench.
        """
        # Delegate to Agent
        self.agent.StepFal(callback)

    def GetCycleCount(self) -> int:
        """
        Get current simulation cycle count.

        Returns:
            Number of cycles executed since InitClock

        Example:
            cycle = dut.GetCycleCount()
            print(f"Current cycle: {cycle}")
        """
        # Delegate to Agent
        return self.agent.GetCycleCount()

    def Finish(self):
        """
        Finish simulation and cleanup.

        Example:
            dut.Finish()
        """
        print(f"[Finish] Simulation completed. Total cycles: {self.agent.GetCycleCount()}")

    def GetAgent(self):
        """Get underlying Agent object."""
        return self.agent

    def __repr__(self):
        fields = []
        {% for data in variables -%}
        fields.append(f"{{data.name}}={self._xpins['{{data.name}}'].xdata.value}")
        {% endfor -%}
        if self.agent._clock_enabled:
            fields.append(f"cycle={self.agent.GetCycleCount()}")
        return f"DUT{{package_name}}({', '.join(fields)})"

    def RefreshComb(self):
        """Refresh combinational logic (not supported in pack mode)."""
        self.InitClock()
        print("this function is not supported in pack mode")

    def SetWaveform(self, filename: str):
        """Set waveform output file (not supported in pack mode)."""
        print(f"[SetWaveform] Not supported in pack mode. Use VCS +vcdpluson+<filename>")

    def GetWaveFormat(self) -> str:
        """Get waveform file extension (returns empty string in pack mode)."""
        return ""

    def FlushWaveform(self):
        """Flush waveform data to disk (not supported in pack mode)."""
        print("[FlushWaveform] Not supported in pack mode.")

    def SetCoverage(self, filename: str):
        """Set coverage output file (not supported in pack mode)."""
        print(f"[SetCoverage] Not supported in pack mode. Use VCS -cm <metrics>")

    def GetCovMetrics(self) -> int:
        """Get coverage metrics bitmask (returns 0 in pack mode)."""
        return 0

    def ResumeWaveformDump(self):
        """Resume waveform dumping (not supported in pack mode)."""
        print("[ResumeWaveformDump] Not supported in pack mode")
        return 0

    def PauseWaveformDump(self):
        """Pause waveform dumping (not supported in pack mode)."""
        print("[PauseWaveformDump] Not supported in pack mode")
        return 0

    def WaveformPaused(self) -> int:
        """Check if waveform is paused (returns 0 in pack mode)."""
        return 0

    def CheckPoint(self, name: str) -> int:
        """Create simulation checkpoint (not supported in pack mode)."""
        print(f"[CheckPoint] Not supported in pack mode.")
        return 1

    def Restore(self, name: str) -> int:
        """Restore from checkpoint (not supported in pack mode)."""
        print(f"[Restore] Not supported in pack mode.")
        return 1

    def GetInternalSignal(self, name: str, index: int = -1, is_array: bool = False, use_vpi: bool = False):
        """Get internal signal access (not supported in pack mode)."""
        print(f"[GetInternalSignal] Not supported in pack mode.")
        return None

    def GetInternalSignalList(self, prefix: str = "", deep: int = 99, use_vpi: bool = False) -> List[str]:
        """Get internal signal list (not supported in pack mode)."""
        print(f"[GetInternalSignalList] Not supported in pack mode.")
        return []

    def VPIInternalSignalList(self, prefix: str = "", deep: int = 99) -> List[str]:
        """Get internal signal list via VPI (not supported in pack mode)."""
        print(f"[VPIInternalSignalList] Not supported in pack mode.")
        return []

    def GetXPort(self):
        """Get XPort dictionary for all transactions."""
        return self._xports

    def GetXClock(self):
        """Get XClock-like object."""
        return self.xclock


# Public API for DUT mode
__all__ = [
    "Agent",
    "BaseTransaction",
    "DUT{{package_name}}",
    {% for trans in transactions -%}
    "{{trans.name}}",
    {% endfor -%}
    "u",
    "xsp",
]

{% else -%}
# ============================================================================
# Agent Mode: Standard modular imports
# ============================================================================

# Public API for Agent mode
__all__ = [
    "Agent",
    "BaseTransaction",
    {% for trans in transactions -%}
    "{{trans.name}}",
    {% endfor -%}
    "u",
    "xsp",
]

{% endif -%}
