# File       : DUT{{className}}.py
# Author     : automatically generated by picker
# Date       : {{datenow}}
# Description: DUT abstraction class for {{className}} UVM transaction
#              Provides pin-level interface with automatic state synchronization
# Version    : {{version}}

from typing import Optional, Callable
try:
    from . import xspcomm as xsp
except Exception:
    import xspcomm as xsp

if __package__ or "." in __name__:
    from .{{className}}_xagent import Agent, {{className}}
else:
    from {{className}}_xagent import Agent, {{className}}


class _PinWrapper:
    """
    Wrapper class to provide dut.a.value access instead of dut.a.xdata.value
    This hides the xdata layer and provides a cleaner interface.
    """
    def __init__(self, xpin: xsp.XPin):
        self._xpin = xpin
    
    @property
    def value(self):
        """Get the current value of the pin."""
        return self._xpin.xdata.value
    
    @value.setter
    def value(self, val):
        """Set the value of the pin."""
        self._xpin.xdata.value = val
    
    @property
    def xpin(self):
        """Access the underlying XPin object if needed."""
        return self._xpin
    
    @property
    def xdata(self):
        """Access the underlying XData object if needed."""
        return self._xpin.xdata


class DUT{{className}}:
    """
    DUT abstraction class for {{className}} transaction.
    
    This class wraps the UVM Agent and provides a pin-level interface,
    making test code more intuitive and hardware-like.
    
    Features:
    - Clean attribute access (dut.a.value = 10)
    - Step-based simulation control
    - Automatic state synchronization with UVM monitor
    - Callback mechanism for monitor updates
    - Conflict resolution (Monitor data always wins)
    
    Example:
        >>> dut = DUT{{className}}()
        >>> dut.a.value = 10
        >>> dut.b.value = 20
        >>> dut.Step(1)
        >>> print(dut.a.value)  # Updated by monitor after Step
    """
    
    def __init__(self, *args, **kwargs):
        """
        Initialize DUT with Agent and xspcomm infrastructure.
        
        Args:
            send_port: TLM port name for sending (default: "{{className}}")
            receive_port: TLM port name for receiving (default: "{{className}}_monitor")
            *args: Additional arguments
            **kwargs: Keyword arguments for configuration
        """
        # Initialize xspcomm infrastructure
        self._event = xsp.Event()
        self._xport = xsp.XPort()
        
        # User callback for monitor updates
        self._user_callback: Optional[Callable[['DUT{{className}}'], None]] = None
        
        # Internal state
        self._monitor_data = None  # Latest monitor data
        self._last_sent_trans = None  # Last sent transaction
        
        # Initialize XPin objects for each field
        self._xpins = {}
        {% for data in variables -%}
        self._xpins['{{data.name}}'] = xsp.XPin(xsp.XData({{data.bit_count}}), self._event)
        # Set to immediate write mode for DUT pack to avoid clock cycle delay
        self._xpins['{{data.name}}'].xdata.AsImmWrite()
        self._xport.Add("{{data.name}}", self._xpins['{{data.name}}'].xdata)
        {% endfor %}
        
        # Create wrapped pin accessors
        {% for data in variables -%}
        self.{{data.name}} = _PinWrapper(self._xpins['{{data.name}}'])
        {% endfor %}
        
        # Define monitor callback to update pin values
        def _internal_monitor_callback(msg_bytes: bytes):
            """
            Internal callback for monitor data.
            Updates pin values and triggers user callback.
            
            Note: XData is set to immediate write mode (AsImmWrite), 
            so updates take effect immediately without waiting for clock edge.
            """
            try:
                # Parse received message
                received_trans = {{className}}(msg_bytes)
                
                # Update all pin values (Monitor data always wins)
                {% for data in variables -%}
                self._xpins['{{data.name}}'].xdata.value = received_trans.{{data.name}}.value
                {% endfor %}
                
                # Store for reference
                self._monitor_data = received_trans
                
                # Trigger user callback if registered (called after Step completes)
                # Note: This is stored and will be called at the end of Step()
                self._callback_pending = True
                
            except Exception as e:
                print(f"Error in monitor callback: {e}")
                import traceback
                traceback.print_exc()
        
        # Initialize Agent with monitor callback
        send_port = kwargs.get("send_port", "{{className}}")
        receive_port = kwargs.get("receive_port", "{{className}}")
        
        # Always set up receive port for monitor updates
        self._callback_pending = False
        self.agent = Agent(
            send_port=send_port,
            receive_port=receive_port,
            receive_function=_internal_monitor_callback
        )
    
    def __del__(self):
        """Cleanup resources."""
        pass
    
    ################################
    #         User APIs            #
    ################################
    
    def Step(self, cycles: int = 1):
        """
        Advance simulation by specified number of cycles.
        
        This method:
        1. Sends current pin values as a transaction to UVM Driver
        2. Runs simulation for 'cycles' clock cycles
        3. Receives and updates state from UVM Monitor (automatic)
        4. Triggers user callback if registered
        
        Args:
            cycles: Number of clock cycles to advance (default: 1)
        
        Conflict Resolution:
            User-set values (dut.a.value = 1) are sent to Driver.
            Monitor-received values unconditionally update the pins.
            This ensures DUT always reflects the simulator's actual state.
        
        Example:
            >>> dut.a.value = 10
            >>> dut.b.value = 20
            >>> dut.Step(1)  # Send values and advance
            >>> print(dut.a.value)  # Shows monitor-updated value
        """
        # Step 1: Prepare and send transaction with current pin values
        # IMPORTANT: Create a NEW transaction object each time to avoid async send issues
        trans = {{className}}()
        {% for data in variables -%}
        trans.{{data.name}}.value = self._xpins['{{data.name}}'].xdata.value
        {% endfor %}
        
        # Send to Driver (this is asynchronous, transaction goes into UVMC queue)
        trans.send(self.agent)
        self._last_sent_trans = trans
        
        # Reset callback flag BEFORE simulation so monitor callback can set it
        self._callback_pending = False
        
        # Step 2: Run simulation
        # CRITICAL: Must run simulation immediately after send to process the transaction
        # Without this, rapid sends in a loop will queue up and may be processed out of order
        # Run at least 2 cycles to ensure TLM/UVMC has time to deliver the transaction
        min_cycles_for_delivery = 1
        if cycles < min_cycles_for_delivery:
            self.agent.run(min_cycles_for_delivery)
        else:
            self.agent.run(cycles)
        
        # Step 3: Monitor callback has already updated pins asynchronously during simulation
        # Step 4: Trigger user callback if registered (once per Step call)
        if self._callback_pending and self._user_callback is not None:
            self._user_callback(self)
            # Reset after calling user callback
            self._callback_pending = False
    
    def SetUpdateCallback(self, callback: Optional[Callable[['DUT{{className}}'], None]]):
        """
        Register a callback function to be called after monitor updates.
        
        The callback is triggered once at the end of each Step() call,
        after the monitor has updated the pin values.
        
        Args:
            callback: Function that takes DUT instance as parameter.
                     Set to None to disable callback.
        
        Example:
            >>> def my_callback(dut):
            ...     print(f"Updated: a={dut.a.value}, b={dut.b.value}")
            >>> dut.SetUpdateCallback(my_callback)
            >>> dut.Step(1)  # Will trigger my_callback
        """
        self._user_callback = callback
    
    def SetZero(self):
        """Set all fields to zero (utility method)."""
        {% for data in variables -%}
        self._xpins['{{data.name}}'].xdata.value = 0
        {% endfor %}
    
    def GetXPort(self):
        """
        Get the XPort object for this transaction.
        
        Returns:
            XPort object containing all transaction fields
        """
        return self._xport
    
    def GetAgent(self):
        """
        Get the underlying Agent object.
        
        Returns:
            Agent object for direct TLM communication
        """
        return self.agent
    
    def GetMonitorData(self):
        """
        Get the latest transaction received from monitor.
        
        Returns:
            Latest {{className}} transaction from monitor, or None
        """
        return self._monitor_data
    
    def GetLastSentTransaction(self):
        """
        Get the last transaction sent to Driver.
        
        Returns:
            Last {{className}} transaction sent, or None
        """
        return self._last_sent_trans
    
    ################################
    #      Advanced APIs           #
    ################################
    
    def SendTransaction(self, trans: {{className}}):
        """
        Directly send a transaction object without updating pins.
        
        Args:
            trans: {{className}} transaction to send
        """
        trans.send(self.agent)
        self._last_sent_trans = trans
    
    def UpdateFromTransaction(self, trans: {{className}}):
        """
        Update all pin values from a transaction object.
        
        Args:
            trans: {{className}} transaction to copy values from
        """
        {% for data in variables -%}
        self._xpins['{{data.name}}'].xdata.value = trans.{{data.name}}.value
        {% endfor %}
    
    def __repr__(self):
        """String representation of DUT state."""
        fields = []
        {% for data in variables -%}
        fields.append(f"{{data.name}}={self._xpins['{{data.name}}'].xdata.value}")
        {% endfor %}
        return f"DUT{{className}}({', '.join(fields)})"


if __name__ == "__main__":
    # Simple test
    dut = DUT{{className}}()
    print("DUT{{className}} initialized successfully")
    print(dut)
