# File       : DUT{{className}}.py
# Author     : automatically generated by picker
# Date       : {{datenow}}
# Description: DUT abstraction class for {{className}} UVM transaction
#              This class provides pin-level interface using xspcomm architecture
# Version    : {{version}}

try:
    from . import xspcomm as xsp
except Exception as e:
    import xspcomm as xsp

if __package__ or "." in __name__:
    from .{{className}}_xagent import Agent, {{className}}
else:
    from {{className}}_xagent import Agent, {{className}}


class DUT{{className}}(object):
    """
    DUT abstraction class for {{className}} transaction.
    
    This class wraps the UVM Agent and provides a pin-level interface
    similar to export DUT classes, making test code more intuitive.
    
    Features:
    - Pin-level attribute access (e.g., dut.a.value = 10)
    - Step-based simulation control
    - Automatic state synchronization with UVM monitor
    - XPort organization for multi-transaction support
    
    Example:
        >>> dut = DUT{{className}}()
        >>> dut.a.value = 10
        >>> dut.b.value = 20
        >>> dut.Step(1)
        >>> print(dut.a.value)  # Updated by monitor
    """
    
    def __init__(self, *args, **kwargs):
        """
        Initialize DUT with Agent and xspcomm infrastructure.
        
        Args:
            *args: Additional arguments for Agent initialization
            **kwargs: Keyword arguments for configuration
        """
        # Initialize xspcomm infrastructure (similar to export DUT)
        self.event = xsp.Event()
        
        # Create XPort for this transaction (organize all fields)
        self.xport = xsp.XPort()
        
        # Initialize XClock for timing control (using a dummy Step function for now)
        # Note: In pack mode, we use TLM communication, not direct hardware binding
        self.xclock = None  # Will be set up if needed
        
        # Internal state tracking
        self._dirty = False  # Flag to track if values have been modified
        self._monitor_data = None  # Store latest monitor data
        
        # Initialize all field XData objects (pins)
        {% for data in variables -%}
        self.{{data.name}} = xsp.XPin(xsp.XData({{data.bit_count}}), self.event)
        {% endfor %}
        
        # Add all fields to XPort
        {% for data in variables -%}
        self.xport.Add("{{data.name}}", self.{{data.name}}.xdata)
        {% endfor %}
        
        # Initialize pending transaction (for sending)
        self._pending_trans = {{className}}()
        
        # Initialize current transaction (updated by monitor)
        self._current_trans = {{className}}()
        
        # Define monitor callback to update XData
        def _monitor_callback(msg_bytes):
            """
            Callback function to handle monitor data.
            Updates XData values when monitor sends transaction back.
            """
            try:
                # Parse received message
                received_trans = {{className}}(msg_bytes)
                
                # Update XData values (current state)
                {% for data in variables -%}
                self.{{data.name}}.xdata.value = received_trans.{{data.name}}.value
                {% endfor %}
                
                # Store for reference
                self._current_trans = received_trans
                self._monitor_data = received_trans
                
            except Exception as e:
                print(f"Error in monitor callback: {e}")
        
        # Initialize Agent with monitor callback
        # For DUT mode, we only send transactions to UVM (Pythonâ†’UVM driver)
        # We don't receive from UVM monitor, so receive_port is empty
        send_port = kwargs.get("send_port", "{{className}}")
        receive_port = kwargs.get("receive_port", "")  # Empty by default for send-only mode
        
        # Only create receive port if explicitly requested
        if receive_port:
            self.agent = Agent(
                send_port=send_port,
                receive_port=receive_port,
                receive_function=_monitor_callback
            )
        else:
            # Send-only mode (no monitor callback needed)
            self.agent = Agent(
                send_port=send_port,
                receive_port="",
                receive_function=None
            )
        
    def __del__(self):
        """Cleanup resources."""
        pass
    
    ################################
    #         User APIs            #
    ################################
    
    def Step(self, cycles: int = 1):
        """
        Advance simulation by specified number of cycles.
        
        This method:
        1. Sends current transaction values to UVM
        2. Runs simulation for 'cycles' clock cycles
        3. Receives and updates state from monitor (automatic via callback)
        
        Args:
            cycles: Number of clock cycles to advance (default: 1)
        
        Example:
            >>> dut.a.xdata.value = 10
            >>> dut.b.xdata.value = 20
            >>> dut.Step(1)  # Send current values and advance
            >>> print(dut.a.xdata.value)  # May be updated by monitor if bidirectional
        """
        # Step 1: Always send current XData values as transaction
        # Copy current XData values to pending transaction
        {% for data in variables -%}
        self._pending_trans.{{data.name}}.value = self.{{data.name}}.xdata.value
        {% endfor %}
        
        # Send transaction through Agent
        self._pending_trans.send(self.agent)
        
        # Step 2: Run simulation for specified cycles
        self.agent.run(cycles)
        
        # Step 3: Monitor callback will automatically update XData values
        # (This happens asynchronously through the receive_function if monitor exists)
    
    def SetZero(self):
        """Set all fields to zero (utility method)."""
        {% for data in variables -%}
        self.{{data.name}}.xdata.value = 0
        {% endfor %}
        self._dirty = True
    
    def GetXPort(self):
        """
        Get the XPort object for this transaction.
        
        Returns:
            XPort object containing all transaction fields
        """
        return self.xport
    
    def GetAgent(self):
        """
        Get the underlying Agent object.
        
        Returns:
            Agent object for direct TLM communication
        """
        return self.agent
    
    ################################
    #     Property Overrides       #
    ################################
    
    def __setattr__(self, name, value):
        """
        Override attribute setting to track modifications.
        
        When a field (XPin/XData) is assigned, mark as dirty
        so that Step() knows to send the transaction.
        """
        # Check if this is a field attribute
        if hasattr(self, name) and isinstance(getattr(self, name, None), xsp.XPin):
            # Field assignment detected
            self._dirty = True
        
        # Prevent direct overwriting of XPin objects
        if name in [{% for data in variables %}"{{data.name}}"{%if not loop.is_last %}, {%endif%}{% endfor %}]:
            if hasattr(self, name):
                raise AttributeError(
                    f"Cannot reassign field '{name}'. Use {name}.value or {name}.xdata.value =  instead."
                )
        
        # Call parent setattr
        super().__setattr__(name, value)
    
    ################################
    #      Advanced APIs           #
    ################################
    
    def SendTransaction(self, trans: {{className}}):
        """
        Directly send a transaction object.
        
        Args:
            trans: {{className}} transaction to send
        """
        trans.send(self.agent)
    
    def GetMonitorData(self):
        """
        Get the latest data received from monitor.
        
        Returns:
            Latest {{className}} transaction from monitor, or None
        """
        return self._monitor_data
    
    def UpdateFromTransaction(self, trans: {{className}}):
        """
        Update all XData values from a transaction object.
        
        Args:
            trans: {{className}} transaction to copy values from
        """
        {% for data in variables -%}
        self.{{data.name}}.xdata.value = trans.{{data.name}}.value
        {% endfor %}
        self._dirty = True


if __name__ == "__main__":
    # Simple test
    dut = DUT{{className}}()
    print("DUT{{className}} initialized successfully")
    {% for data in variables -%}
    print(f"  {{data.name}}: {dut.{{data.name}}.xdata.value}")
    {% endfor %}
