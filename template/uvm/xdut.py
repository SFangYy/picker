# File       : {{className}}.py
# Author     : automatically generated by picker
# Date       : {{datenow}}
# Description: DUT abstraction class for {{className}}
#              {% if length(transactions) > 0 %}Multi-transaction unified interface{% else %}Single transaction interface{% endif %}
#              Provides pin-level interface with automatic state synchronization
# Version    : {{version}}

from typing import Optional, Callable, Dict
try:
    from . import xspcomm as xsp
except Exception:
    import xspcomm as xsp

{% if length(transactions) > 0 -%}
# Multi-transaction mode
if __package__ or "." in __name__:
    from .{{className}}_xagent import UnifiedAgent
else:
    from {{className}}_xagent import UnifiedAgent
{% else -%}
# Single transaction mode
if __package__ or "." in __name__:
    from .{{className}}_xagent import Agent, {{className}}
else:
    from {{className}}_xagent import Agent, {{className}}
{% endif -%}


class _PinWrapper:
    """
    Wrapper class to provide dut.a.value access instead of dut.a.xdata.value
    This hides the xdata layer and provides a cleaner interface.
    """
    def __init__(self, xpin: xsp.XPin):
        self._xpin = xpin
    
    @property
    def value(self):
        """Get the current value of the pin."""
        return self._xpin.xdata.value
    
    @value.setter
    def value(self, val):
        """Set the value of the pin."""
        self._xpin.xdata.value = val
    
    @property
    def xpin(self):
        """Access the underlying XPin object if needed."""
        return self._xpin
    
    @property
    def xdata(self):
        """Access the underlying XData object if needed."""
        return self._xpin.xdata


class DUT{{className}}:
    """
    DUT abstraction class for {{className}}.
    
    {% if transactions -%}
    Multi-transaction mode - manages multiple transaction types:
    {% for trans in transactions -%}
    - {{trans.name}}
    {% endfor %}
    
    All pins from all transactions are exposed as attributes:
    {% for data in variables -%}
    - {{data.name}}: {{data.bit_count}}-bit signal{% if data.transaction_name %} (from {{data.transaction_name}}){% endif %}
    {% endfor %}
    {% else -%}
    Single transaction mode.
    
    Fields:
    {% for data in variables -%}
    - {{data.name}}: {{data.bit_count}}-bit signal
    {% endfor %}
    {% endif -%}
    
    Features:
    - Clean attribute access (dut.pin.value = val)
    - Step-based simulation control
    - Automatic state synchronization with UVM monitor
    - Callback mechanism for monitor updates
    
    Example:
        >>> dut = {{className}}()
        >>> dut.a.value = 10
        >>> dut.b.value = 20
        >>> dut.Step(1)
        >>> print(dut.a.value)  # Updated by monitor after Step
    """
    
    def __init__(self, *args, **kwargs):
        """
        Initialize DUT with Agent and xspcomm infrastructure.
        
        Args:
            {% if transactions -%}
            send_port_<trans>: TLM port name for sending (per transaction)
            receive_port_<trans>: TLM port name for receiving (per transaction)
            {% else -%}
            send_port: TLM port name for sending (default: "{{className}}")
            receive_port: TLM port name for receiving (default: "{{className}}")
            {% endif -%}
            *args: Additional arguments
            **kwargs: Keyword arguments for configuration
        """
        # Initialize xspcomm infrastructure
        self._event = xsp.Event()
        {% if transactions -%}
        self._xports: Dict[str, xsp.XPort] = {}
        {% else -%}
        self._xport = xsp.XPort()
        {% endif -%}
        
        # User callback for monitor updates
        self._user_callback: Optional[Callable[['{{className}}'], None]] = None
        
        # Internal state
        {% if transactions -%}
        self._monitor_data: Dict[str, any] = {}
        self._last_sent_data: Dict[str, any] = {}
        {% else -%}
        self._monitor_data = None  # Latest monitor data
        self._last_sent_trans = None  # Last sent transaction
        {% endif -%}
        
        # Initialize XPin objects for each field
        self._xpins = {}
        
        {% if transactions -%}
        # Multi-transaction mode: organize pins by transaction
        {% for trans in transactions -%}
        # Pins from transaction: {{trans.name}}
        self._xports['{{trans.name}}'] = xsp.XPort()
        {% for data in trans.variables -%}
        self._xpins['{{data.name}}'] = xsp.XPin(xsp.XData({{data.bit_count}}), self._event)
        self._xpins['{{data.name}}'].xdata.AsImmWrite()
        self._xports['{{trans.name}}'].Add("{{data.name}}", self._xpins['{{data.name}}'].xdata)
        {% endfor %}
        
        {% endfor -%}
        {% else -%}
        # Single transaction mode
        {% for data in variables -%}
        self._xpins['{{data.name}}'] = xsp.XPin(xsp.XData({{data.bit_count}}), self._event)
        self._xpins['{{data.name}}'].xdata.AsImmWrite()
        self._xport.Add("{{data.name}}", self._xpins['{{data.name}}'].xdata)
        {% endfor -%}
        {% endif -%}
        
        # Create wrapped pin accessors
        {% for data in variables -%}
        self.{{data.name}} = _PinWrapper(self._xpins['{{data.name}}'])
        {% endfor %}
        
        {% if transactions -%}
        # Multi-transaction mode: unified agent callback
        def _internal_monitor_callback(trans_name: str, msg_bytes: bytes):
            """Internal callback for multi-transaction monitor data."""
            try:
                self._monitor_data[trans_name] = msg_bytes
                
                # Parse and update pin values based on transaction type
                # Find which transaction this data belongs to
                {% for trans in transactions -%}
                if trans_name == '{{trans.name}}':
                    # Decode the bytes and update corresponding pins
                    # msg_bytes format: all fields concatenated as bytes
                    byte_idx = 0
                    {% for data in trans.variables -%}
                    # Update {{data.name}} ({{data.bit_count}} bits = {{data.nums}} bytes)
                    field_bytes = msg_bytes[byte_idx:byte_idx+{{data.nums}}]
                    if len(field_bytes) == {{data.nums}}:
                        {% if data.nums == 1 -%}
                        self._xpins['{{data.name}}'].xdata.value = field_bytes[0]
                        {% else -%}
                        # Multi-byte field: combine bytes (big-endian)
                        value = int.from_bytes(field_bytes, byteorder='big')
                        self._xpins['{{data.name}}'].xdata.value = value
                        {% endif -%}
                    byte_idx += {{data.nums}}
                {% endfor -%}
                {% endfor -%}
                
                self._callback_pending = True
            except Exception as e:
                print(f"Error in monitor callback for {trans_name}: {e}")
                import traceback
                traceback.print_exc()
        
        # Initialize unified agent
        self._callback_pending = False
        self.agent = UnifiedAgent(
            monitor_callback=_internal_monitor_callback,
            **kwargs
        )
        {% else -%}
        # Single transaction mode: standard callback
        def _internal_monitor_callback(msg_bytes: bytes):
            """
            Internal callback for monitor data.
            Updates pin values and triggers user callback.
            """
            try:
                # Parse received message
                received_trans = {{className}}(msg_bytes)
                
                # Update all pin values (Monitor data always wins)
                {% for data in variables -%}
                self._xpins['{{data.name}}'].xdata.value = received_trans.{{data.name}}.value
                {% endfor %}
                
                # Store for reference
                self._monitor_data = received_trans
                self._callback_pending = True
                
            except Exception as e:
                print(f"Error in monitor callback: {e}")
                import traceback
                traceback.print_exc()
        
        # Initialize Agent with monitor callback
        send_port = kwargs.get("send_port", "{{className}}")
        receive_port = kwargs.get("receive_port", "{{className}}")
        
        self._callback_pending = False
        self.agent = Agent(
            send_port=send_port,
            receive_port=receive_port,
            receive_function=_internal_monitor_callback
        )
        {% endif %}
    
    def __del__(self):
        """Cleanup resources."""
        pass
    
    ################################
    #         User APIs            #
    ################################
    
    def Step(self, cycles: int = 1):
        """
        Advance simulation by specified number of cycles.
        
        {% if transactions -%}
        Multi-transaction mode:
        1. Collects values from all pins
        2. Routes values to appropriate transactions
        3. Sends all updated transactions to UVM
        4. Runs simulation for 'cycles' clock cycles
        5. Receives and updates state from monitors
        {% else -%}
        Single transaction mode:
        1. Sends current pin values as a transaction to UVM Driver
        2. Runs simulation for 'cycles' clock cycles
        3. Receives and updates state from UVM Monitor
        {% endif -%}
        
        Args:
            cycles: Number of clock cycles to advance (default: 1)
        
        Example:
            >>> dut.a.value = 10
            >>> dut.b.value = 20
            >>> dut.Step(1)
            >>> print(dut.a.value)  # Updated by monitor
        """
        {% if transactions -%}
        # Multi-transaction mode: collect and route values
        trans_values: Dict[str, Dict[str, int]] = {}
        
        {% for trans in transactions -%}
        # Values for {{trans.name}}
        trans_values['{{trans.name}}'] = {
            {%- for data in trans.variables %}
            '{{data.name}}': self._xpins['{{data.name}}'].xdata.value,
            {%- endfor %}
        }
        {% endfor %}
        
        # Send all transactions
        self.agent.send_all(trans_values)
        self._last_sent_data = trans_values.copy()
        
        # Reset callback flag
        self._callback_pending = False
        
        # Run simulation with extra cycles for monitor feedback
        # Monitor needs time to process and return data (pipeline delay)
        monitor_feedback_cycles = 2  # Extra cycles for round-trip communication
        total_cycles = cycles + monitor_feedback_cycles
        self.agent.run(total_cycles)
        
        # Wait for monitor callback with timeout
        max_wait_iterations = 10
        wait_count = 0
        while not self._callback_pending and wait_count < max_wait_iterations:
            self.agent.run(1)
            wait_count += 1
        
        # Trigger user callback if set
        if self._callback_pending and self._user_callback is not None:
            self._user_callback(self)
            self._callback_pending = False
        {% else -%}
        # Single transaction mode: send transaction
        trans = {{className}}()
        {% for data in variables -%}
        trans.{{data.name}}.value = self._xpins['{{data.name}}'].xdata.value
        {% endfor %}
        
        trans.send(self.agent)
        self._last_sent_trans = trans
        
        # Reset callback flag
        self._callback_pending = False
        
        # Run simulation with extra cycles for monitor feedback
        # Monitor needs time to process and return data (pipeline delay)
        monitor_feedback_cycles = 2  # Extra cycles for round-trip communication
        min_cycles_for_delivery = 1
        
        if cycles < min_cycles_for_delivery:
            total_cycles = min_cycles_for_delivery + monitor_feedback_cycles
        else:
            total_cycles = cycles + monitor_feedback_cycles
        
        self.agent.run(total_cycles)
        
        # Wait for monitor callback with timeout
        max_wait_iterations = 10
        wait_count = 0
        while not self._callback_pending and wait_count < max_wait_iterations:
            self.agent.run(1)
            wait_count += 1
        
        # Trigger user callback if set
        if self._callback_pending and self._user_callback is not None:
            self._user_callback(self)
            self._callback_pending = False
        {% endif %}
    
    def SetUpdateCallback(self, callback: Optional[Callable[['DUT{{className}}'], None]]):
        """
        Register a callback function to be called after monitor updates.
        
        The callback is triggered once at the end of each Step() call,
        after the monitor has updated the pin values.
        
        Args:
            callback: Function that takes DUT instance as parameter.
                     Set to None to disable callback.
        
        Example:
            >>> def my_callback(dut):
            ...     print(f"Updated: a={dut.a.value}, b={dut.b.value}")
            >>> dut.SetUpdateCallback(my_callback)
            >>> dut.Step(1)  # Will trigger my_callback
        """
        self._user_callback = callback
    
    def SetZero(self):
        """Set all fields to zero (utility method)."""
        {% for data in variables -%}
        self._xpins['{{data.name}}'].xdata.value = 0
        {% endfor %}
    
    def GetXPort(self):
        """
        Get the XPort object for this transaction.
        
        Returns:
            XPort object containing all transaction fields
        """
        return self._xport
    
    def GetAgent(self):
        """
        Get the underlying Agent object.
        
        Returns:
            Agent object for direct TLM communication
        """
        return self.agent
    
    def GetMonitorData(self):
        """
        Get the latest transaction received from monitor.
        
        Returns:
            Latest {{className}} transaction from monitor, or None
        """
        return self._monitor_data
    
    def GetLastSentTransaction(self):
        """
        Get the last transaction sent to Driver.
        
        Returns:
            Last {{className}} transaction sent, or None
        """
        return self._last_sent_trans
    
    ################################
    #      Advanced APIs           #
    ################################
    
    def SendTransaction(self, trans: {{className}}):
        """
        Directly send a transaction object without updating pins.
        
        Args:
            trans: {{className}} transaction to send
        """
        trans.send(self.agent)
        self._last_sent_trans = trans
    
    def UpdateFromTransaction(self, trans: {{className}}):
        """
        Update all pin values from a transaction object.
        
        Args:
            trans: {{className}} transaction to copy values from
        """
        {% for data in variables -%}
        self._xpins['{{data.name}}'].xdata.value = trans.{{data.name}}.value
        {% endfor %}
    
    def __repr__(self):
        """String representation of DUT state."""
        fields = []
        {% for data in variables -%}
        fields.append(f"{{data.name}}={self._xpins['{{data.name}}'].xdata.value}")
        {% endfor %}
        return f"DUT{{className}}({', '.join(fields)})"


if __name__ == "__main__":
    # Simple test
    dut = DUT{{className}}()
    print("DUT{{className}} initialized successfully")
    print(dut)
