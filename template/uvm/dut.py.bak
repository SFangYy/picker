# File       : __init__.py
# Author     : automatically generated by picker
# Date       : {{date_now}}
# Description: Python package initialization for {{package_name}}
# Version    : {{version}}

"""
{{package_name}} Python Package

UVM transaction-based communication package.
"""

__version__ = "{{version}}"

# ============================================================================
# Common imports for both DUT and Agent modes
# ============================================================================
try:
    from . import tlm_pbsb as u
    from . import xspcomm as xsp
    from .xagent import Agent, BaseTransaction{% for trans in transactions %}, {{trans.name}}{% endfor %}
except ImportError as e:
    import sys
    print(f"Error: Failed to import required modules: {e}", file=sys.stderr)
    print("Make sure tlm_pbsb, xspcomm, and xagent modules are properly installed.", file=sys.stderr)
    raise

{% if generate_dut -%}
# ============================================================================
# DUT Mode: Integrated __init__.py with DUT implementation
# ============================================================================

from typing import Optional, Callable, Dict, Type, List
import struct
import os
import sys
import subprocess

# ============================================================================
# Unified Initialization: Path handling + LD_PRELOAD
# ============================================================================
{% if __SIMULATOR__ == "vcs" %}
# VCS Mode: Auto LD_PRELOAD handling
dut_dir = os.path.dirname(os.path.abspath(__file__))
so_path = os.path.join(dut_dir, '_tlm_pbsb.so')

# Convert paths to absolute (always do this)
def _to_abs(arg):
    if arg.startswith('-'):
        return arg
    if '::' in arg:
        path, test = arg.split('::', 1)
        return f"{os.path.abspath(path)}::{test}" if os.path.exists(path) else arg
    return os.path.abspath(arg) if os.path.exists(arg) else arg

new_args = [_to_abs(arg) for arg in sys.argv]

# Handle LD_PRELOAD and directory switching
if '_LD_PRELOAD_HANDLED' not in os.environ and os.environ.get('SKIP_LD_PRELOAD') != '1':
    if os.path.exists(so_path):
        # Setup environment
        env = os.environ.copy()
        env['LD_PRELOAD'] = f"{so_path}:{env.get('LD_PRELOAD', '')}" if env.get('LD_PRELOAD') else so_path
        env['_LD_PRELOAD_HANDLED'] = '1'
        env['PYTHONPATH'] = os.path.dirname(dut_dir)
        
        # Run in DUT directory if needed
        if os.path.abspath(os.getcwd()) != dut_dir:
            is_pytest = 'pytest' in sys.modules or 'PYTEST_CURRENT_TEST' in os.environ
            result = subprocess.run(
                [sys.executable] + new_args, env=env, cwd=dut_dir,
                capture_output=is_pytest, text=is_pytest
            )
            
            if is_pytest:
                print(result.stdout, end='')
                print(result.stderr, end='', file=sys.stderr)
                # Handle VCS crash but tests passed
                if result.returncode < 0 and ' passed' in (result.stdout + result.stderr):
                    os._exit(0)
            
            os._exit(result.returncode if result.returncode >= 0 else 1)
        else:
            os.execve(sys.executable, [sys.executable] + new_args, env)
{% endif %}


# ==================== DUT Implementation ====================

class _PinWrapper:
    """Wrapper to provide dut.pin.value access instead of dut.pin.xdata.value"""
    def __init__(self, xpin: xsp.XPin):
        self._xpin = xpin

    @property
    def value(self):
        return self._xpin.xdata.value

    @value.setter
    def value(self, val):
        self._xpin.xdata.value = val

    @property
    def xpin(self):
        return self._xpin

    @property
    def xdata(self):
        return self._xpin.xdata

    @property
    def event(self):
        return self._xpin.event  

class DUT{{package_name}}:
    """
    DUT abstraction for {{package_name}} with pin-level interface.

    Pins:
    {% for data in variables -%}
    - {{data.name}}: {{data.bit_count}}-bit signal
    {% endfor -%}
    Example:
        >>> dut = DUT{{package_name}}()
        {%- for data in variables -%}
        {%- if loop.index == 1 %}
        >>> dut.{{data.name}}.value = 10
        {%- endif -%}
        {%- endfor %}
        >>> dut.Step(1)
    """

    def __init__(self, **kwargs):
        """Initialize DUT with Agent and xspcomm infrastructure."""
        self._event = xsp.Event()
        self._xports: Dict[str, xsp.XPort] = {}
        self._user_callback: Optional[Callable[['DUT{{package_name}}'], None]] = None
        self._xpins = {}
        self._callback_pending = False

        # Monitor feedback extra cycles (configurable)
        self._monitor_extra_cycles: int = kwargs.get('monitor_extra_cycles', 1)

        # Initialize XPins and XPorts per transaction
        {% for trans in transactions -%}
        # Transaction: {{trans.name}}
        self._xports['{{trans.name}}'] = xsp.XPort()
        {% for data in trans.variables -%}
        self._xpins['{{data.name}}'] = xsp.XPin(xsp.XData({{data.bit_count}}), self._event)
        self._xpins['{{data.name}}'].xdata.AsImmWrite()
        self._xports['{{trans.name}}'].Add("{{data.name}}", self._xpins['{{data.name}}'].xdata)
        {% endfor -%}

        {% endfor -%}
        # Create pin accessors
        {% for data in variables -%}
        self.{{data.name}} = _PinWrapper(self._xpins['{{data.name}}'])
        {% endfor -%}

        # Monitor callback
        def _monitor_callback(trans_type: str, trans_obj):
            """Internal callback for monitor updates."""
            try:
                # Update pins from received transaction
                {% for trans in transactions %}
                if trans_type == '{{trans.name}}':   
                    {% for data in trans.variables -%}
                    self._xpins['{{data.name}}'].xdata.value = trans_obj.{{data.name}}.value
                    {% endfor -%}                            
                {% endfor %}
                self._callback_pending = True
            except Exception as e:
                print(f"Monitor callback error: {e}")

        # Initialize unified Agent (disable auto_register, we'll register manually)
        self.agent = Agent(monitor_callback=_monitor_callback, auto_register=False)

        # Register all transaction types
        {% for trans in transactions -%}
        send_port = kwargs.get('send_port_{{trans.name}}', '{{trans.name}}')
        receive_port = kwargs.get('receive_port_{{trans.name}}', '{{trans.name}}')
        self.agent.register_transaction({{trans.name}}, send_port=send_port, receive_port=receive_port)
        {% endfor %}
        self.dut = self

        class _Clock:
            def __init__(self, agent): self.agent = agent
            @property
            def clk(self): return self.agent._cycle_count
        self.xclock = _Clock(self.agent)

    def Step(self, cycles: int = 1):
        """
        Advance simulation by specified cycles.
        1. Send current pin values as transactions
        2. Run simulation
        3. Update pins from monitor
        4. Execute clock callbacks (after monitor update)
        """
        for i in range(cycles):
            # Create and drive transactions
            {% for trans in transactions -%}
            tr = {{trans.name}}()
            {% for data in trans.variables -%}
            tr.{{data.name}}.value = self._xpins['{{data.name}}'].xdata.value
            {% endfor -%}
            self.agent.drive(tr)
            {% endfor -%}
            self._callback_pending = False

            # Run 1 cycle WITHOUT triggering callbacks yet
            self.agent.run(1, count_cycles=False)

            # Run extra cycles for monitor feedback without counting
            self.agent.run(self._monitor_extra_cycles, count_cycles=False)

            # Wait for monitor callback (without counting cycles)
            wait_count = 0
            while not self._callback_pending and wait_count < 10:
                self.agent.run(1, count_cycles=False)
                wait_count += 1

            # Trigger user callback
            if self._callback_pending and self._user_callback:
                self._user_callback(self)
                self._callback_pending = False

            # NOW increment cycle and trigger callbacks after monitor update
            if self.agent._clock_enabled:
                self.agent._cycle_count += 1
                for callback in self.agent._posedge_callbacks:
                    callback(self.agent._cycle_count)

    def SetUpdateCallback(self, callback: Optional[Callable[['DUT{{package_name}}'], None]]):
        """Register callback after monitor updates."""
        self._user_callback = callback

    def SetZero(self):
        """Set all pins to zero."""
        {% for data in variables -%}
        self._xpins['{{data.name}}'].xdata.value = 0
        {% endfor %}

    def InitClock(self, clock_pin: Optional[str] = None, domain: str = "default", frequency: Optional[float] = None):
        """
        Initialize clock tracking and management.

        Args:
            clock_pin: Name of the clock pin (optional, for validation only)
                      If None, clock tracking works without pin validation
            domain: Clock domain name for documentation (default: "default")
            frequency: Optional clock frequency in Hz

        Example:
            dut.InitClock()  # Simple cycle counting
            dut.InitClock("clk")  # Validate clock pin exists
            dut.InitClock("clk", domain="sys_clk", frequency=100e6)
        """
        if clock_pin is not None and clock_pin not in self._xpins:
            raise ValueError(f"Clock pin '{clock_pin}' not found. Available pins: {list(self._xpins.keys())}")

        # Delegate to Agent
        self.agent.InitClock(domain=domain, frequency=frequency)

    def StepRis(self, callback: Callable[[int], None]):
        """
        Register callback for clock rising edge.

        Args:
            callback: Function that takes cycle number as argument

        Example:
            def on_posedge(cycle):
                print(f"Cycle {cycle}: value = {dut.pin.value}")

            dut.StepRis(on_posedge)
        """
        # Delegate to Agent
        self.agent.StepRis(callback)

    def StepFal(self, callback: Callable[[int], None]):
        """
        Register callback for clock falling edge.

        Args:
            callback: Function that takes cycle number as argument

        Note: Currently falling edge callbacks are not triggered in Pack mode
              as the clock is managed by SystemVerilog testbench.
        """
        # Delegate to Agent
        self.agent.StepFal(callback)

    def GetCycleCount(self) -> int:
        """
        Get current simulation cycle count.

        Returns:
            Number of cycles executed since InitClock

        Example:
            cycle = dut.GetCycleCount()
            print(f"Current cycle: {cycle}")
        """
        # Delegate to Agent
        return self.agent.GetCycleCount()

    def Finish(self):
        """
        Finish simulation and cleanup.

        Example:
            dut.Finish()
        """
        print(f"[Finish] Simulation completed. Total cycles: {self.agent.GetCycleCount()}")

    def GetAgent(self):
        """Get underlying Agent object."""
        return self.agent

    def __repr__(self):
        fields = []
        {% for data in variables -%}
        fields.append(f"{{data.name}}={self._xpins['{{data.name}}'].xdata.value}")
        {% endfor -%}
        if self.agent._clock_enabled:
            fields.append(f"cycle={self.agent.GetCycleCount()}")
        return f"DUT{{package_name}}({', '.join(fields)})"

    def RefreshComb(self):
        """Refresh combinational logic (not supported in pack mode)."""
        self.InitClock()
        print("this function is not supported in pack mode")

    def SetWaveform(self, filename: str):
        """Set waveform output file (not supported in pack mode)."""
        print(f"[SetWaveform] Not supported in pack mode. Use VCS +vcdpluson+<filename>")

    def GetWaveFormat(self) -> str:
        """Get waveform file extension (returns empty string in pack mode)."""
        return ""

    def FlushWaveform(self):
        """Flush waveform data to disk (not supported in pack mode)."""
        print("[FlushWaveform] Not supported in pack mode.")

    def SetCoverage(self, filename: str):
        """Set coverage output file (not supported in pack mode)."""
        print(f"[SetCoverage] Not supported in pack mode. Use VCS -cm <metrics>")

    def GetCovMetrics(self) -> int:
        """Get coverage metrics bitmask (returns 0 in pack mode)."""
        return 0

    def ResumeWaveformDump(self):
        """Resume waveform dumping (not supported in pack mode)."""
        print("[ResumeWaveformDump] Not supported in pack mode")
        return 0

    def PauseWaveformDump(self):
        """Pause waveform dumping (not supported in pack mode)."""
        print("[PauseWaveformDump] Not supported in pack mode")
        return 0

    def WaveformPaused(self) -> int:
        """Check if waveform is paused (returns 0 in pack mode)."""
        return 0

    def CheckPoint(self, name: str) -> int:
        """Create simulation checkpoint (not supported in pack mode)."""
        print(f"[CheckPoint] Not supported in pack mode.")
        return 1

    def Restore(self, name: str) -> int:
        """Restore from checkpoint (not supported in pack mode)."""
        print(f"[Restore] Not supported in pack mode.")
        return 1

    def GetInternalSignal(self, name: str, index: int = -1, is_array: bool = False, use_vpi: bool = False):
        """Get internal signal access (not supported in pack mode)."""
        print(f"[GetInternalSignal] Not supported in pack mode.")
        return None

    def GetInternalSignalList(self, prefix: str = "", deep: int = 99, use_vpi: bool = False) -> List[str]:
        """Get internal signal list (not supported in pack mode)."""
        print(f"[GetInternalSignalList] Not supported in pack mode.")
        return []

    def VPIInternalSignalList(self, prefix: str = "", deep: int = 99) -> List[str]:
        """Get internal signal list via VPI (not supported in pack mode)."""
        print(f"[VPIInternalSignalList] Not supported in pack mode.")
        return []

    def GetXPort(self):
        """Get XPort dictionary for all transactions."""
        return self._xports

    def GetXClock(self):
        """Get XClock-like object."""
        return self.xclock


# Public API for DUT mode
__all__ = [
    "Agent",
    "BaseTransaction",
    "DUT{{package_name}}",
    {% for trans in transactions -%}
    "{{trans.name}}",
    {% endfor -%}
    "u",
    "xsp",
]

{% else -%}
# ============================================================================
# Agent Mode: Standard modular imports
# ============================================================================

# Public API for Agent mode
__all__ = [
    "Agent",
    "BaseTransaction",
    {% for trans in transactions -%}
    "{{trans.name}}",
    {% endfor -%}
    "u",
    "xsp",
]

{% endif -%}
