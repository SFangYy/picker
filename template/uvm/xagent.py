# File       : {{className}}_xagent.py
# Author     : automatically generated by picker
# Date       : {{datenow}}
# Description: {%  if length(transactions) > 0 %}Multi-transaction unified agent{% else %}Single transaction agent{% endif %} for UVM-Python communication
# Version    : {{version}}

from typing import Optional, List, Callable, Dict
import struct

# Support both standalone and package imports
try:
    from . import tlm_pbsb as u
    from . import xspcomm as xsp
except ImportError:
    import tlm_pbsb as u
    import xspcomm as xsp

class Agent:
    """
    The Agent is used to initialize UVM project and build/connect port with UVM.
    
    This class manages TLM communication between UVM and Python environments,
    handling both sending and receiving of transaction data.
    
    Attributes:
        send_port: TLM publication port for sending messages to UVM
        receive_port: TLM subscription port for receiving messages from UVM
    
    Example:
        >>> agent = Agent(send_port="test_channel", 
        ...               receive_port="test_channel",
        ...               receive_function=lambda msg: print(msg))
        >>> agent.run(100)  # Drive 100 clock cycles
    """

    def __init__(self,
                 send_port: str = "",
                 receive_port: str = "",
                 receive_function: Optional[Callable[[bytes], None]] = None) -> None:
        """
        Initialize a TLM port connected to UVM.

        Args:
            send_port: Name of the TLM publication port for sending data
            receive_port: Name of the TLM subscription port for receiving data
            receive_function: Callback function to process received sequences

        Raises:
            ValueError: If receive_port is specified but receive_function is None
        """
        # Parameter validation: receive_port requires receive_function
        if receive_port != "" and receive_function is None:
            raise ValueError(
                f"receive_function must be provided when receive_port ('{receive_port}') is specified. "
                "The callback function is required to handle received messages."
            )

        u.tlm_vcs_init("_tlm_pbsb.so", "-no_save")
        if send_port != "":
            self.send_port = u.TLMPub(send_port)
            self.send_port.Connect()
        if receive_port != "" and receive_function is not None:
            self.receive_port = u.TLMSub(receive_port, lambda a: receive_function(a.as_bytes()))
            self.receive_port.Connect()

    def run(self, nums: int) -> None:
        """
        Drive UVM clock cycles.
        
        Args:
            nums: Number of clock cycles to execute
        """ 
        for i in range(nums):
            u.step(1)

class {{className}}:
    """
    UVM Transaction wrapper for Python interoperability.
    
    This class handles serialization/deserialization of UVM transaction
    items for TLM communication between UVM and Python environments.
    
    Attributes:
        {% for data in variables -%}
        {{data.name}} (XData): Transaction field ({{data.bit_count}} bits)
        {% endfor %}
    
    Example:
        >>> tr = {{className}}()
        >>> # Set field values
        {%- for data in variables %}
        >>> tr.{{data.name}}.value = 0x0
        {%- endfor %}
        >>> tr.send(agent)
        >>> 
        >>> # Receive from UVM
        >>> received_msg = b'...'
        >>> tr2 = {{className}}(received_msg)
    """

    def __init__(self, msg: Optional[bytes] = None) -> None:
        """Initialize transaction with optional message data.
        
        Args:
            msg: Optional byte message to deserialize
        """
        {%for data in variables -%}
        self.{{data.name}} = xsp.XData({{data.bit_count}})
        {%endfor -%}
        if msg is not None:
            self.from_msg(msg)

    def from_msg(self, msg: bytes) -> None:
        """
        Convert message received from UVM to Python transaction.

        Args:
            msg: Byte message received from UVM

        Raises:
            ValueError: If message length is invalid
        """
        # Boundary check: validate message length
        expected_length = {{byte_stream_count}}
        if len(msg) < expected_length:
            raise ValueError(
                f"Invalid message length: expected at least {expected_length} bytes, "
                f"got {len(msg)} bytes"
            )

        {%for data in variables -%}
        {%if data.macro == 1 -%}
        {{data.macro_name}} = {{data.bit_count}}
        {%endif -%}
        {%endfor -%}
        # Optimized deserialization with boundary checking
        {%for data in variables -%}
        {%if data.nums == 1 -%}
        self.{{data.name}}.value = msg[{{data.byte_offset}}]
        {%else -%}
        self.{{data.name}}.value = int.from_bytes(msg[{{data.byte_offset}}:{{data.byte_offset + data.nums}}], byteorder='big')
        {%endif -%}
        {%endfor %}
    
    def to_bytes(self) -> bytes:
        """
        Convert transaction to byte stream using optimized serialization.

        Returns:
            Serialized byte stream

        Note:
            Uses struct.pack for standard-aligned fields (1/2/4/8 bytes) and
            bytearray with bit operations for non-standard alignments.
        """
        result = bytearray({{byte_stream_count}})
        offset = 0

        {%- for data in variables %}
        # {{data.name}}: {{data.bit_count}} bits ({{data.nums}} bytes)
        value_{{loop.index}} = self.{{data.name}}.value
        {%- if data.is_standard_aligned %}
        # Standard-aligned field: use struct.pack
        struct.pack_into('>{{data.struct_fmt}}', result, offset, value_{{loop.index}})
        offset += {{data.nums}}
        {%- else %}
        # Non-standard alignment: use bit operations
        for i in range({{data.nums}}):
            result[offset + i] = (value_{{loop.index}} >> (8 * ({{data.nums}} - 1 - i))) & 0xFF
        offset += {{data.nums}}
        {%- endif %}
        {%- endfor %}

        return bytes(result)

    def send(self, env: Agent) -> None:
        """
        Serialize and send transaction to UVM.

        Args:
            env: Agent instance with active send_port
        """
        byte_stream = self.to_bytes()

        uvm_message = u.tlm_msg()
        uvm_message.from_bytes(byte_stream)
        env.send_port.SendMsg(uvm_message)
    
    def __repr__(self) -> str:
        """String representation showing field values."""
        fields = ', '.join([
            {%- for data in variables %}
            f"{{data.name}}={self.{{data.name}}.value}"{%if not loop.is_last -%},{%endif -%}
            {%- endfor %}
        ])
        return f"{{className}}({fields})"

class {{className}}_list:
    """
    Container for multiple {{className}} transactions.
    
    This class parses a continuous byte stream into individual transactions.
    
    Attributes:
        sequence_list: List of deserialized {{className}} transactions
    
    Example:
        >>> msg_stream = b'...'  # Multiple concatenated transactions
        >>> tr_list = {{className}}_list(msg_stream)
        >>> for tr in tr_list.sequence_list:
        ...     print(tr.field1.value)
    """
    
    def __init__(self, message: bytes) -> None:
        """Initialize and parse message stream.
        
        Args:
            message: Byte stream containing one or more transactions
        """
        self.sequence_list: List[{{className}}] = []
        if len(message) != 0:
            self.to_list(message)
    
    def to_list(self, message: bytes) -> None:
        """
        Parse message stream into individual transactions with validation.
        
        Args:
            message: Byte stream to parse
        """
        chunk_size = {{byte_stream_count}}
        
        # Validate message length
        if len(message) % chunk_size != 0:
            print(f"Warning: message length {len(message)} is not a multiple of "
                  f"chunk_size {chunk_size}. Last incomplete chunk will be skipped.")
        
        index = 0
        while index < len(message):
            chunk = message[index:index + chunk_size]
            # Only process complete chunks
            if len(chunk) == chunk_size:
                tr = {{className}}(chunk)
                self.sequence_list.append(tr)
            else:
                print(f"Warning: Incomplete chunk at offset {index}: "
                      f"{len(chunk)}/{chunk_size} bytes. Skipping.")
            index += chunk_size

{% if transactions -%}
# ============================================================================
# Multi-Transaction Support
# ============================================================================

{% for trans in transactions -%}
class {{trans.name}}:
    """
    UVM Transaction: {{trans.name}}
    
    Fields:
    {% for data in trans.variables -%}
    - {{data.name}}: {{data.bit_count}} bits
    {% endfor %}
    """
    
    def __init__(self, msg: Optional[bytes] = None) -> None:
        """Initialize transaction with optional message data."""
        {%- for data in trans.variables %}
        self.{{data.name}} = xsp.XData({{data.bit_count}})
        {%- endfor %}
        if msg is not None:
            self.from_msg(msg)
    
    def from_msg(self, msg: bytes) -> None:
        """
        Deserialize from UVM message.

        Args:
            msg: Byte message received from UVM

        Raises:
            ValueError: If message length is invalid
        """
        # Boundary check: validate message length
        expected_length = {{trans.byte_stream_count}}
        if len(msg) < expected_length:
            raise ValueError(
                f"Invalid message length for {{trans.name}}: expected at least {expected_length} bytes, "
                f"got {len(msg)} bytes"
            )

        {%- for data in trans.variables %}
        {%- if data.macro == 1 %}
        {{data.macro_name}} = {{data.bit_count}}
        {%- endif %}
        {%- endfor %}
        # Optimized deserialization with boundary checking
        {%- for data in trans.variables %}
        {%- if data.nums == 1 %}
        self.{{data.name}}.value = msg[{{data.byte_offset}}]
        {%- else %}
        self.{{data.name}}.value = int.from_bytes(msg[{{data.byte_offset}}:{{data.byte_offset + data.nums}}], byteorder='big')
        {%- endif %}
        {%- endfor %}

    def to_bytes(self) -> bytes:
        """
        Convert transaction to byte stream using optimized serialization.

        Returns:
            Serialized byte stream

        Note:
            Uses struct.pack for standard-aligned fields (1/2/4/8 bytes) and
            bytearray with bit operations for non-standard alignments.
        """
        result = bytearray({{trans.byte_stream_count}})
        offset = 0

        {%- for data in trans.variables %}
        # {{data.name}}: {{data.bit_count}} bits ({{data.nums}} bytes)
        value_{{loop.index}} = self.{{data.name}}.value
        {%- if data.is_standard_aligned %}
        # Standard-aligned field: use struct.pack
        struct.pack_into('>{{data.struct_fmt}}', result, offset, value_{{loop.index}})
        offset += {{data.nums}}
        {%- else %}
        # Non-standard alignment: use bit operations
        for i in range({{data.nums}}):
            result[offset + i] = (value_{{loop.index}} >> (8 * ({{data.nums}} - 1 - i))) & 0xFF
        offset += {{data.nums}}
        {%- endif %}
        {%- endfor %}

        return bytes(result)
    
    def __repr__(self) -> str:
        """String representation."""
        fields = ', '.join([
            {%- for data in trans.variables %}
            f"{{data.name}}={self.{{data.name}}.value}"{%- if not loop.is_last -%},{%- endif -%}
            {%- endfor %}
        ])
        return f"{{trans.name}}({fields})"


{% endfor %}

class UnifiedAgent:
    """
    Unified Agent managing multiple transaction types.
    
    This agent handles:
    {% for trans in transactions -%}
    - {{trans.name}}
    {% endfor %}
    """
    
    def __init__(self, 
                 monitor_callback: Optional[Callable[[str, bytes], None]] = None,
                 **kwargs) -> None:
        """
        Initialize unified agent with TLM communication.
        
        Args:
            monitor_callback: Callback function(trans_name, msg_bytes) for monitor data
            **kwargs: Additional configuration options
        """
        # Initialize TLM
        u.tlm_vcs_init("_tlm_pbsb.so", "-no_save")
        
        # Transaction-specific ports
        self._send_ports: Dict[str, any] = {}
        self._receive_ports: Dict[str, any] = {}
        
        # Transaction classes
        self._trans_classes = {
            {%- for trans in transactions %}
            '{{trans.name}}': {{trans.name}},
            {%- endfor %}
        }
        
        # Store callback
        self._monitor_callback = monitor_callback
        
        # Set up send/receive ports for each transaction
        {% for trans in transactions -%}
        # {{trans.name}} ports
        send_port_name = kwargs.get('send_port_{{trans.name}}', '{{trans.name}}')
        if send_port_name:
            self._send_ports['{{trans.name}}'] = u.TLMPub(send_port_name)
            self._send_ports['{{trans.name}}'].Connect()

        receive_port_name = kwargs.get('receive_port_{{trans.name}}', '{{trans.name}}')
        if receive_port_name and monitor_callback:
            # Fix closure issue: use functools.partial or create a proper closure
            def _make_callback(trans_name):
                return lambda a: self._handle_monitor_msg(trans_name, a.as_bytes())

            self._receive_ports['{{trans.name}}'] = u.TLMSub(
                receive_port_name,
                _make_callback('{{trans.name}}')
            )
            self._receive_ports['{{trans.name}}'].Connect()

        {% endfor %}
    
    def _handle_monitor_msg(self, trans_name: str, msg_bytes: bytes):
        """Internal handler for monitor messages."""
        if self._monitor_callback:
            self._monitor_callback(trans_name, msg_bytes)
    
    def send_transaction(self, trans_name: str, values: Dict[str, int]):
        """Send a single transaction."""
        if trans_name not in self._trans_classes:
            raise ValueError(f"Unknown transaction type: {trans_name}")
        
        if trans_name not in self._send_ports:
            return
        
        # Create transaction instance
        trans_class = self._trans_classes[trans_name]
        trans = trans_class()
        
        # Set field values
        for field_name, value in values.items():
            if hasattr(trans, field_name):
                getattr(trans, field_name).value = value
        
        # Send via TLM
        byte_stream = trans.to_bytes()
        uvm_message = u.tlm_msg()
        uvm_message.from_bytes(byte_stream)
        self._send_ports[trans_name].SendMsg(uvm_message)
    
    def send_all(self, trans_values: Dict[str, Dict[str, int]]):
        """Send all transactions with updated values."""
        for trans_name, values in trans_values.items():
            if values:
                self.send_transaction(trans_name, values)
    
    def run(self, cycles: int) -> None:
        """Drive UVM clock cycles."""
        for i in range(cycles):
            u.step(1)
    
    def get_transaction_class(self, trans_name: str):
        """Get transaction class by name."""
        return self._trans_classes.get(trans_name)

{% endif -%}