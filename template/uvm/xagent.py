# File       : xagent.py
# Author     : automatically generated by picker
# Date       : {{datenow}}
# Description: This is a template generated by picker. Use this, you can achieve 
#              communication between UVM and Python.
# Version    : {{version}}
from typing import Optional, List, Callable
import tlm_pbsb as u
import xspcomm as xsp

class Agent:
    """
    The Agent is used to initialize UVM project and build/connect port with UVM.
    
    This class manages TLM communication between UVM and Python environments,
    handling both sending and receiving of transaction data.
    
    Attributes:
        send_port: TLM publication port for sending messages to UVM
        receive_port: TLM subscription port for receiving messages from UVM
    
    Example:
        >>> agent = Agent(send_port="test_channel", 
        ...               receive_port="test_channel",
        ...               receive_function=lambda msg: print(msg))
        >>> agent.run(100)  # Drive 100 clock cycles
    """

    def __init__(self, 
                 send_port: str = "", 
                 receive_port: str = "", 
                 receive_function: Optional[Callable[[bytes], None]] = None) -> None:
        """
        Initialize a TLM port connected to UVM.
        
        Args:
            send_port: Name of the TLM publication port for sending data
            receive_port: Name of the TLM subscription port for receiving data
            receive_function: Callback function to process received sequences
        """

        u.tlm_vcs_init("_tlm_pbsb.so", "-no_save")
        if send_port != "":
            self.send_port = u.TLMPub(send_port)
            self.send_port.Connect()
        if receive_port != "" and receive_function is not None:
            self.receive_port = u.TLMSub(receive_port, lambda a: receive_function(a.as_bytes()))
            self.receive_port.Connect()

    def run(self, nums: int) -> None:
        """
        Drive UVM clock cycles.
        
        Args:
            nums: Number of clock cycles to execute
        """ 
        for i in range(nums):
            u.step(1)

class {{className}}:
    """
    UVM Transaction wrapper for Python interoperability.
    
    This class handles serialization/deserialization of UVM transaction
    items for TLM communication between UVM and Python environments.
    
    Attributes:
        {% for data in variables -%}
        {{data.name}} (XData): Transaction field ({{data.bit_count}} bits)
        {% endfor %}
    
    Example:
        >>> tr = {{className}}()
        >>> # Set field values
        {%- for data in variables %}
        >>> tr.{{data.name}}.value = 0x0
        {%- endfor %}
        >>> tr.send(agent)
        >>> 
        >>> # Receive from UVM
        >>> received_msg = b'...'
        >>> tr2 = {{className}}(received_msg)
    """

    def __init__(self, msg: Optional[bytes] = None) -> None:
        """Initialize transaction with optional message data.
        
        Args:
            msg: Optional byte message to deserialize
        """
        {%for data in variables -%}
        self.{{data.name}} = xsp.XData({{data.bit_count}})
        {%endfor -%}
        if msg is not None:
            self.from_msg(msg)

    def from_msg(self, msg: bytes) -> None:
        """
        Convert message received from UVM to Python transaction.
        
        Args:
            msg: Byte message received from UVM
        """
        {%for data in variables -%}
        {%if data.macro == 1 -%}
        {{data.macro_name}} = {{data.bit_count}}
        {%endif -%}
        {%endfor -%}
        {% set counter = 0 -%}
        # Directly deserialize fields without nested function
        {%for data in variables -%}
        {%if data.nums == 1 -%}
        self.{{data.name}}.value = msg[{{counter}}]
        {% set counter = counter + 1 -%}
        {%else -%}
        self.{{data.name}}.value = int.from_bytes(msg[{{counter}}:{%for i in range(data.nums) -%}{% set counter = counter + 1 -%}{%endfor -%}{{counter}}], byteorder='big')
        {%endif -%}
        {%endfor %}
    
    def _serialize_field(self, value: int, bit_count: int) -> str:
        """
        Serialize a single field to binary string with padding.
        
        Args:
            value: Field value to serialize
            bit_count: Number of bits for this field
            
        Returns:
            Binary string with proper byte alignment
        """
        binary_str = bin(value)[2:].zfill(bit_count)
        padding = 8 - len(binary_str) % 8
        if padding != 8:
            binary_str = '0' * padding + binary_str
        return binary_str
    
    def send(self, env: Agent) -> None:
        """
        Convert transaction to byte stream and send to UVM.
        
        Args:
            env: Agent instance with active send_port
        """
        # Use list comprehension and join for efficient string concatenation
        byte_str = ''.join([
            {%- for data in variables %}
            self._serialize_field(self.{{data.name}}.value, {{data.bit_count}}){%if not loop.is_last -%},{%endif -%}
            {%- endfor %}
        ])
        
        # Convert binary string to bytes efficiently
        byte_list = [int(byte_str[i:i+8], 2).to_bytes(1, 'big') 
                     for i in range(0, len(byte_str), 8)]
        byte_stream = b''.join(byte_list)
        
        uvm_message = u.tlm_msg()
        uvm_message.from_bytes(byte_stream)
        env.send_port.SendMsg(uvm_message)

class {{className}}_list:
    """
    Container for multiple {{className}} transactions.
    
    This class parses a continuous byte stream into individual transactions.
    
    Attributes:
        sequence_list: List of deserialized {{className}} transactions
    
    Example:
        >>> msg_stream = b'...'  # Multiple concatenated transactions
        >>> tr_list = {{className}}_list(msg_stream)
        >>> for tr in tr_list.sequence_list:
        ...     print(tr.field1.value)
    """
    
    def __init__(self, message: bytes) -> None:
        """Initialize and parse message stream.
        
        Args:
            message: Byte stream containing one or more transactions
        """
        self.sequence_list: List[{{className}}] = []
        if len(message) != 0:
            self.to_list(message)
    
    def to_list(self, message: bytes) -> None:
        """
        Parse message stream into individual transactions with validation.
        
        Args:
            message: Byte stream to parse
        """
        chunk_size = {{byte_stream_count}}
        
        # Validate message length
        if len(message) % chunk_size != 0:
            print(f"Warning: message length {len(message)} is not a multiple of "
                  f"chunk_size {chunk_size}. Last incomplete chunk will be skipped.")
        
        index = 0
        while index < len(message):
            chunk = message[index:index + chunk_size]
            # Only process complete chunks
            if len(chunk) == chunk_size:
                tr = {{className}}(chunk)
                self.sequence_list.append(tr)
            else:
                print(f"Warning: Incomplete chunk at offset {index}: "
                      f"{len(chunk)}/{chunk_size} bytes. Skipping.")
            index += chunk_size
