# File       : {{className}}_xagent.py
# Author     : automatically generated by picker
# Date       : {{datenow}}
# Description: Unified agent for UVM-Python communication
# Version    : {{version}}

from typing import Optional, Callable, Dict, Type, List
import struct

try:
    from . import tlm_pbsb as u
    from . import xspcomm as xsp
except ImportError:
    import tlm_pbsb as u
    import xspcomm as xsp


class BaseTransaction:
    """Base class for UVM transactions with common serialization logic."""

    _fields_metadata: List[tuple] = []
    _byte_stream_count: int = 0
    _transaction_type: str = "BaseTransaction"

    def __init__(self, msg: Optional[bytes] = None) -> None:
        self._init_fields()
        if msg is not None:
            self.from_msg(msg)

    def _init_fields(self) -> None:
        raise NotImplementedError(f"{self.__class__.__name__} must implement _init_fields()")

    def from_msg(self, msg: bytes) -> None:
        """Deserialize from UVM message."""
        if len(msg) < self._byte_stream_count:
            raise ValueError(
                f"Invalid message length for {self._transaction_type}: "
                f"expected {self._byte_stream_count} bytes, got {len(msg)} bytes"
            )

        for name, _, byte_offset, nums, _, _ in self._fields_metadata:
            if nums == 1:
                getattr(self, name).value = msg[byte_offset]
            else:
                getattr(self, name).value = int.from_bytes(
                    msg[byte_offset:byte_offset + nums], byteorder='big'
                )

    def to_bytes(self) -> bytes:
        """Serialize to byte stream."""
        result = bytearray(self._byte_stream_count)
        offset = 0

        for name, _, _, nums, is_aligned, fmt in self._fields_metadata:
            value = getattr(self, name).value
            if is_aligned:
                struct.pack_into(f'>{fmt}', result, offset, value)
            else:
                for i in range(nums):
                    result[offset + i] = (value >> (8 * (nums - 1 - i))) & 0xFF
            offset += nums

        return bytes(result)

    def __repr__(self) -> str:
        fields = ', '.join([f"{field[0]}={getattr(self, field[0]).value}" for field in self._fields_metadata])
        return f"{self._transaction_type}({fields})"


{% for trans in transactions -%}
class {{trans.name}}(BaseTransaction):
    """{{trans.name}} transaction ({{trans.byte_stream_count}} bytes)"""

    _transaction_type = "{{trans.name}}"
    _byte_stream_count = {{trans.byte_stream_count}}
    _fields_metadata = [
        {% for data in trans.variables -%}
        ("{{data.name}}", {{data.bit_count}}, {{data.byte_offset}}, {{data.nums}}, {% if data.is_standard_aligned %}True{% else %}False{% endif %}, '{{data.struct_fmt}}'),
        {% endfor -%}
    ]

    def _init_fields(self) -> None:
        {% for data in trans.variables -%}
        self.{{data.name}} = xsp.XData({{data.bit_count}})
        {% endfor -%}


{% endfor %}
class Agent:
    """Unified agent managing transaction types and TLM communication."""

    def __init__(self, monitor_callback: Optional[Callable[[str, BaseTransaction], None]] = None, auto_register: bool = True) -> None:
        u.tlm_vcs_init("_tlm_pbsb.so", "-no_save")
        self._send_ports: Dict[str, any] = {}
        self._receive_ports: Dict[str, any] = {}
        self._transaction_registry: Dict[str, Type[BaseTransaction]] = {}
        self._monitor_callback = monitor_callback

        # Auto-register all transaction types with default ports
        if auto_register:
            {% for trans in transactions -%}
            self.register_transaction({{trans.name}}, send_port="{{trans.name}}", receive_port="{{trans.name}}")
            {% endfor %}

    def register_transaction(self, trans_class: Type[BaseTransaction],
                            send_port: Optional[str] = None,
                            receive_port: Optional[str] = None) -> None:
        """Register transaction type with communication ports."""
        trans_type = trans_class._transaction_type
        self._transaction_registry[trans_type] = trans_class

        if send_port:
            port = u.TLMPub(send_port)
            port.Connect()
            self._send_ports[trans_type] = port

        if receive_port:
            if not self._monitor_callback:
                print(f"Warning: receive_port '{receive_port}' specified but no monitor_callback provided.")
            else:
                def make_callback(t_type, t_class):
                    return lambda msg: self._monitor_callback(t_type, t_class(msg.as_bytes()))

                port = u.TLMSub(receive_port, make_callback(trans_type, trans_class))
                port.Connect()
                self._receive_ports[trans_type] = port

    def drive(self, transaction: BaseTransaction) -> None:
        """Drive transaction to UVM with automatic port routing."""
        trans_type = transaction._transaction_type

        if trans_type not in self._send_ports:
            raise ValueError(f"No send port for '{trans_type}'. Call register_transaction() first.")

        byte_stream = transaction.to_bytes()
        uvm_message = u.tlm_msg()
        uvm_message.from_bytes(byte_stream)
        self._send_ports[trans_type].SendMsg(uvm_message)

    def run(self, cycles: int) -> None:
        """Drive UVM clock cycles."""
        for _ in range(cycles):
            u.step(1)
