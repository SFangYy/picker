//==============================================================================//
// File       : {{className}}_xagent.sv
// Author     : automatically generated by picker
// Date       : {{datenow}}
// Description: This is a template generated by picker. use this,you can  achieve 
//              communication between UVM and Python.
// Version    : {{version}}
//==============================================================================//

class {{className}}_xmonitor extends uvm_monitor;
    `uvm_component_utils({{className}}_xmonitor)
    
    // Parameters for timing and configuration
    localparam real TIME_UNIT = 1e-12;        // Time precision
    localparam real TRANSPORT_DELAY = 1e-9;   // Transport delay
    
    // Member variables with consistent naming
    uvm_tlm_b_initiator_socket #()     out;
    byte unsigned                      m_transport_data[];
    byte unsigned                      m_transport_queue[];
    uvm_tlm_gp                         m_transport_msg;
    uvm_tlm_time                       m_delay;
    bit                                m_exist_xmonitor;
    {{className}}                      m_tr;

    function new(string name, uvm_component parent=null);
        super.new(name,parent);
        uvm_config_db#(bit)::get(this,"","{{className}}_exist_xmonitor",m_exist_xmonitor);
        if(m_exist_xmonitor) begin
            out = new("out",this);
        end
        
        m_transport_msg = new;
        m_delay = new("delay", TIME_UNIT);
    endfunction

    // Uses parameterized max width for better flexibility
    parameter int MAX_FIELD_WIDTH = 2048;  // Configurable maximum field width
    
    task automatic serialize_field(
        input bit [MAX_FIELD_WIDTH-1:0] data, 
        input int bit_count, 
        ref byte unsigned transport_array[]
    );
        int l_remaining_bits;
        logic[7:0] l_byte_buffer;
        
        l_remaining_bits = bit_count % 8;
        
        // Handle remaining bits (non-byte-aligned)
        if(l_remaining_bits != 0) begin
            l_byte_buffer = 8'b00000000;
            for(int i = 0; i < l_remaining_bits; i++) begin
                l_byte_buffer[l_remaining_bits - i - 1] = data[bit_count - 1 - i];
            end
            transport_array = {transport_array, l_byte_buffer};
        end
        
        // Handle complete bytes
        for(int i = 0; i < bit_count / 8; i++) begin
            transport_array = {transport_array, data[(bit_count - 1 - l_remaining_bits - i*8) -: 8]};
        end
    endtask

    
    virtual task run_phase(uvm_phase phase);
        // Monitor should not actively send transactions in DUT mode
        // It should only respond when explicitly driven by sequence_send
        // For DUT pack mode, monitor echoes back what driver receives
        forever begin
            #100;  // Wait indefinitely, only send when explicitly called
        end
    endtask


    virtual task sequence_send({{className}} tr);
        // This task is called by external logic to send specific transaction
        // For DUT pack mode, this should echo the received driver data
        send_tr(tr);
    endtask

    task send_tr({{className}} {{className}}item);
        // Initialize transaction data
        m_transport_data = {};
        
        {% set counter =  0 -%}
        {%for data in variables -%}
        {%if data.nums == 1 -%}
        {% set counter = counter + 1 -%}
        m_transport_data = {m_transport_data, {{className}}item.{{data.name}}};
        {%else -%}
        {%if data.macro == 1 -%}
        serialize_field({{className}}item.{{data.name}}, {{data.macro_name}}, m_transport_data);
        {% set counter = counter + 1 -%}
        {%else -%}
        serialize_field({{className}}item.{{data.name}}, {{data.bit_count}}, m_transport_data);
        {% set counter = counter + 1 -%}
        {%endif -%}
        {%endif -%}
        {%endfor -%}
        
        m_transport_msg.set_data_length(m_transport_data.size());
        m_transport_msg.set_data(m_transport_data);
        m_delay.set_abstime(0, TRANSPORT_DELAY);
        if(m_exist_xmonitor) begin
            out.b_transport(m_transport_msg, m_delay);
        end
    endtask

    task send_transaction({{className}} {{className}}item, logic is_last);
        byte unsigned l_temp_data[];
        l_temp_data = {};
        
        {% set counter =  0 -%}
        {%for data in variables -%}
        {%if data.nums == 1 -%}
        {% set counter = counter + 1 -%}
        l_temp_data = {l_temp_data, {{className}}item.{{data.name}}};
        {%else -%}
        {%if data.macro == 1 -%}
        serialize_field({{className}}item.{{data.name}}, {{data.macro_name}}, l_temp_data);
        {% set counter = counter + 1 -%}
        {%else -%}
        serialize_field({{className}}item.{{data.name}}, {{data.bit_count}}, l_temp_data);
        {% set counter = counter + 1 -%}
        {%endif -%}
        {%endif -%}
        {%endfor -%}
        send_msg(l_temp_data, is_last);
    endtask

    task send_msg(byte unsigned tr[], logic is_last);
        for(int i = 0; i < tr.size(); i++) begin
            m_transport_queue = {m_transport_queue, tr[i]};
        end
        if(is_last) begin
            m_transport_msg.set_data_length(m_transport_queue.size());
            m_transport_msg.set_data(m_transport_queue);
            out.b_transport(m_transport_msg, m_delay);
            m_transport_queue = {};
        end
    endtask

endclass
    
    
class {{className}}_xdriver extends uvm_driver;
    `uvm_component_utils({{className}}_xdriver)
    
    // Parameters for timing
    localparam real TIME_UNIT = 1e-12;
    
    // Member variables
    uvm_tlm_gp                         m_transport_msg;
    uvm_tlm_time                       m_delay;
    byte unsigned                      m_transport_data[];
    bit                                m_exist_xdriver;
    uvm_tlm_b_target_socket #({{className}}_xdriver)        in;
    {{className}}                      m_tr;
    {{className}}_xmonitor             mon_handle;  // Handle to monitor for echo back

    function new(string name, uvm_component parent=null);
        super.new(name,parent);
        if(!uvm_config_db#(bit)::get(this,"","{{className}}_exist_xdriver",m_exist_xdriver)) begin
            `uvm_fatal("CFGERR", "Could not get monitor or driver type")
        end
        if(m_exist_xdriver) begin
            in = new("in",this);
        end
        
        m_transport_msg = new("transport_msg");
        m_delay = new("delay", TIME_UNIT);
    endfunction
        

    virtual task b_transport(uvm_tlm_gp t, uvm_tlm_time delay);
        m_tr = new("tr");
        t.get_data(m_transport_data);
        {% set counter =  0 -%}
        {%for data in variables -%}
        {%if data.nums == 1 -%}
        m_tr.{{data.name}} = m_transport_data[{{counter}}];
        {% set counter = counter + 1 -%}
        {%else -%}
        m_tr.{{data.name}} = { {%for i in range(data.nums) -%}m_transport_data[{{counter}}]{%if not loop.is_last -%},{%endif -%}{% set counter = counter + 1 -%} {% endfor -%} };
        {%endif -%}
        {%endfor -%}
        delay.reset();
        sequence_receive(m_tr);
    endtask

    virtual task sequence_receive({{className}} tr);
        // Override this task in derived class
    endtask
endclass


class {{className}}_xagent_config extends uvm_object;
    string                             mon_channel_name;
    string                             drv_channel_name;
    uvm_object_wrapper                 mon_type;
    uvm_object_wrapper                 drv_type;

    function new(string name = "{{className}}_xagent_config");
        super.new(name);
        this.mon_channel_name = "{{className}}";
        this.drv_channel_name = "{{className}}";
    endfunction
endclass


class {{className}}_xagent extends uvm_agent;
    `uvm_component_utils({{className}}_xagent) 
    
    uvm_component                      mon_inst;
    uvm_component                      drv_inst;
    string                             mon_channel;
    string                             drv_channel;
    {{className}}_xagent_config      cfg;
    {{className}}_xmonitor           {{className}}_xmon;
    {{className}}_xdriver            {{className}}_xdrv;

    function new(string name,uvm_component parent = null);
        super.new(name,parent);
        if (!uvm_config_db#({{className}}_xagent_config)::get(this, "", "{{className}}_xagent_config", cfg)) begin
            `uvm_fatal("CFGERR", "Could not get xagent_config")
        end 
        else if(cfg.mon_type == null && cfg.drv_type ==null) begin
            `uvm_fatal("CFGERR", "Could not get monitor or driver type")
        end
        if (cfg.mon_type != null) begin
            uvm_config_db#(bit)::set(null,"","{{className}}_exist_xmonitor",1'b1);
        end
        else begin
            uvm_config_db#(bit)::set(null,"","{{className}}_exist_xmonitor",1'b0);
        end

        if (cfg.drv_type != null) begin
            uvm_config_db#(bit)::set(null,"","{{className}}_exist_xdriver",1'b1);
        end 
        else begin
            uvm_config_db#(bit)::set(null,"","{{className}}_exist_xdriver",1'b0);
        end    
    endfunction

    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        if(cfg.mon_type != null) begin
            mon_channel = $sformatf("%s%s", cfg.mon_channel_name,"_sub");
            mon_inst = cfg.mon_type.create_component(mon_channel,this);
            $cast({{className}}_xmon, mon_inst);
        end
        if(cfg.drv_type != null) begin
            drv_channel = $sformatf("%s%s", cfg.drv_channel_name,".pub");
            drv_inst = cfg.drv_type.create_component(drv_channel,this);
            $cast({{className}}_xdrv,drv_inst);
        end
        
    endfunction


    function void connect();
        mon_channel = $sformatf("%s%s", cfg.mon_channel_name,".sub");
        drv_channel = $sformatf("%s%s", cfg.drv_channel_name,".pub");
        
        if(cfg.mon_type != null) begin
          uvmc_tlm #()::connect({{className}}_xmon.out,mon_channel);
        end

        if(cfg.drv_type != null) begin
          uvmc_tlm #()::connect({{className}}_xdrv.in,drv_channel);        
        end
    endfunction

endclass
