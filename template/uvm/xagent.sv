//==============================================================================//
// File       : {{className}}_xagent.sv
// Author     : automatically generated by picker
// Date       : {{datenow}}
// Description: UVM-Python communication agent template
// Version    : {{version}}
//==============================================================================//

// Import common utility package for serialization functions
import utils_pkg::*;

{% if transaction_count > 0 -%}
{% for trans in transactions -%}
//==============================================================================
// Transaction: {{trans.name}}
//==============================================================================

class {{trans.name}}_xmonitor extends uvm_monitor;
    `uvm_component_utils({{trans.name}}_xmonitor)

    localparam real TIME_UNIT = 1e-12;
    localparam real TRANSPORT_DELAY = 1e-9;

    uvm_tlm_b_initiator_socket #() out;
    byte unsigned m_transport_data[];
    uvm_tlm_gp m_transport_msg;
    uvm_tlm_time m_delay;
    uvm_active_passive_enum m_exist_xmonitor;
    {{trans.name}} m_tr;

    function new(string name, uvm_component parent=null);
        super.new(name,parent);
        if(!uvm_config_db#(uvm_active_passive_enum)::get(this,"","{{trans.name}}_exist_xmonitor",m_exist_xmonitor))
            m_exist_xmonitor = UVM_ACTIVE; // Default to active if not configured
        out = new("out",this);
        m_transport_msg = new;
        m_delay = new("delay", TIME_UNIT);
    endfunction

    virtual task run_phase(uvm_phase phase);
        // Monitor typically doesn't need an active run_phase unless actively sampling
        // Remove forever loop to prevent simulation hang
        // Users can override this method if active monitoring is needed
    endtask

    virtual task sequence_send({{trans.name}} tr);
        // Optimized serialization using pre-allocated array and utility functions
        m_transport_data = new[{{trans.byte_stream_count}}];
        {% for data in trans.variables -%}
        {% if data.macro == 1 -%}
        serialize_field_inplace(tr.{{data.name}}, {{data.macro_name}}, m_transport_data, {{data.byte_offset}});
        {% else -%}
        serialize_field_inplace(tr.{{data.name}}, {{data.bit_count}}, m_transport_data, {{data.byte_offset}});
        {% endif -%}
        {% endfor -%}
        m_transport_msg.set_data_length({{trans.byte_stream_count}});
        m_transport_msg.set_data(m_transport_data);
        m_delay.set_abstime(0, TRANSPORT_DELAY);
        out.b_transport(m_transport_msg, m_delay);
    endtask

endclass
    
class {{trans.name}}_xdriver extends uvm_driver;
    `uvm_component_utils({{trans.name}}_xdriver)

    localparam real TIME_UNIT = 1e-12;

    uvm_tlm_gp m_transport_msg;
    uvm_tlm_time m_delay;
    byte unsigned m_transport_data[];
    uvm_tlm_b_target_socket #({{trans.name}}_xdriver) in;
    {{trans.name}} m_tr;

    function new(string name, uvm_component parent=null);
        super.new(name,parent);
        in = new("in",this);
        m_transport_msg = new("transport_msg");
        m_delay = new("delay", TIME_UNIT);
    endfunction

    virtual task b_transport(uvm_tlm_gp t, uvm_tlm_time delay);
        m_tr = new("tr");
        t.get_data(m_transport_data);
        // Deserialize using optimized utility functions
        {% for data in trans.variables -%}
        {% if data.nums == 1 -%}
        m_tr.{{data.name}} = m_transport_data[{{data.byte_offset}}];
        {% else -%}
        {% if data.macro == 1 -%}
        m_tr.{{data.name}} = deserialize_field(m_transport_data, {{data.byte_offset}}, {{data.macro_name}});
        {% else -%}
        m_tr.{{data.name}} = deserialize_field(m_transport_data, {{data.byte_offset}}, {{data.bit_count}});
        {% endif -%}
        {% endif -%}
        {% endfor -%}
        delay.reset();
        sequence_receive(m_tr);
    endtask

    virtual task sequence_receive({{trans.name}} tr);
    endtask
endclass

class {{trans.name}}_xagent_config extends uvm_object;
    // UVM standard configuration using is_active
    uvm_active_passive_enum is_active = UVM_ACTIVE;  // UVM_ACTIVE: monitor+driver, UVM_PASSIVE: monitor only
    string channel_name;    // TLM channel name for both monitor and driver

    `uvm_object_utils_begin({{trans.name}}_xagent_config)
        `uvm_field_enum(uvm_active_passive_enum, is_active, UVM_DEFAULT)
        `uvm_field_string(channel_name, UVM_DEFAULT)
    `uvm_object_utils_end

    function new(string name = "{{trans.name}}_xagent_config");
        super.new(name);
        this.channel_name = "{{trans.name}}";
    endfunction
endclass

class {{trans.name}}_xagent extends uvm_agent;
    `uvm_component_utils({{trans.name}}_xagent)

    {{trans.name}}_xagent_config cfg;
    {{trans.name}}_xmonitor {{trans.name}}_xmon;
    {{trans.name}}_xdriver {{trans.name}}_xdrv;

    function new(string name, uvm_component parent = null);
        super.new(name,parent);
        if (!uvm_config_db#({{trans.name}}_xagent_config)::get(this, "", "{{trans.name}}_xagent_config", cfg))
            `uvm_fatal("CFGERR", "Could not get xagent_config")

        // Set is_active for monitor (always exists, just needs to know mode for potential internal logic)
        uvm_config_db#(uvm_active_passive_enum)::set(this, "*", "{{trans.name}}_exist_xmonitor", cfg.is_active);
    endfunction

    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        // Monitor always created (both ACTIVE and PASSIVE modes have monitors)
        {{trans.name}}_xmon = {{trans.name}}_xmonitor::type_id::create($sformatf("%s_sub", cfg.channel_name), this);

        // Driver only created in ACTIVE mode
        if(cfg.is_active == UVM_ACTIVE) begin
            {{trans.name}}_xdrv = {{trans.name}}_xdriver::type_id::create($sformatf("%s.pub", cfg.channel_name), this);
        end
    endfunction

    // Standard UVM connect_phase for TLM connections
    function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);

        // Monitor TLM connection (always present)
        uvmc_tlm #()::connect({{trans.name}}_xmon.out, $sformatf("%s.sub", cfg.channel_name));

        // Driver TLM connection (only in ACTIVE mode)
        if(cfg.is_active == UVM_ACTIVE) begin
            uvmc_tlm #()::connect({{trans.name}}_xdrv.in, $sformatf("%s.pub", cfg.channel_name));
        end
    endfunction

endclass

{% endfor -%}
{% else -%}

class {{className}}_xmonitor extends uvm_monitor;
    `uvm_component_utils({{className}}_xmonitor)

    localparam real TIME_UNIT = 1e-12;
    localparam real TRANSPORT_DELAY = 1e-9;

    uvm_tlm_b_initiator_socket #() out;
    byte unsigned m_transport_data[];
    uvm_tlm_gp m_transport_msg;
    uvm_tlm_time m_delay;
    uvm_active_passive_enum m_exist_xmonitor;
    {{className}} m_tr;

    function new(string name, uvm_component parent=null);
        super.new(name,parent);
        if(!uvm_config_db#(uvm_active_passive_enum)::get(this,"","{{className}}_exist_xmonitor",m_exist_xmonitor))
            m_exist_xmonitor = UVM_ACTIVE; // Default to active if not configured
        out = new("out",this);
        m_transport_msg = new;
        m_delay = new("delay", TIME_UNIT);
    endfunction

    virtual task run_phase(uvm_phase phase);
        // Monitor typically doesn't need an active run_phase unless actively sampling
        // Remove forever loop to prevent simulation hang
        // Users can override this method if active monitoring is needed
    endtask

    virtual task sequence_send({{className}} tr);
        // Optimized serialization using pre-allocated array and utility functions
        m_transport_data = new[{{byte_stream_count}}];
        {% for data in variables -%}
        {% if data.macro == 1 -%}
        serialize_field_inplace(tr.{{data.name}}, {{data.macro_name}}, m_transport_data, {{data.byte_offset}});
        {% else -%}
        serialize_field_inplace(tr.{{data.name}}, {{data.bit_count}}, m_transport_data, {{data.byte_offset}});
        {% endif -%}
        {% endfor -%}
        m_transport_msg.set_data_length({{byte_stream_count}});
        m_transport_msg.set_data(m_transport_data);
        m_delay.set_abstime(0, TRANSPORT_DELAY);
        out.b_transport(m_transport_msg, m_delay);
    endtask

endclass

class {{className}}_xdriver extends uvm_driver;
    `uvm_component_utils({{className}}_xdriver)

    localparam real TIME_UNIT = 1e-12;

    uvm_tlm_gp m_transport_msg;
    uvm_tlm_time m_delay;
    byte unsigned m_transport_data[];
    uvm_tlm_b_target_socket #({{className}}_xdriver) in;
    {{className}} m_tr;
    {{className}}_xmonitor mon_handle;

    function new(string name, uvm_component parent=null);
        super.new(name,parent);
        in = new("in",this);
        m_transport_msg = new("transport_msg");
        m_delay = new("delay", TIME_UNIT);
    endfunction

    virtual task b_transport(uvm_tlm_gp t, uvm_tlm_time delay);
        m_tr = new("tr");
        t.get_data(m_transport_data);
        // Deserialize using optimized utility functions
        {% for data in variables -%}
        {% if data.nums == 1 -%}
        m_tr.{{data.name}} = m_transport_data[{{data.byte_offset}}];
        {% else -%}
        {% if data.macro == 1 -%}
        m_tr.{{data.name}} = deserialize_field(m_transport_data, {{data.byte_offset}}, {{data.macro_name}});
        {% else -%}
        m_tr.{{data.name}} = deserialize_field(m_transport_data, {{data.byte_offset}}, {{data.bit_count}});
        {% endif -%}
        {% endif -%}
        {% endfor -%}
        delay.reset();
        sequence_receive(m_tr);
    endtask

    virtual task sequence_receive({{className}} tr);
    endtask
endclass

class {{className}}_xagent_config extends uvm_object;
    // UVM standard configuration using is_active
    uvm_active_passive_enum is_active = UVM_ACTIVE;  // UVM_ACTIVE: monitor+driver, UVM_PASSIVE: monitor only
    string channel_name;    // TLM channel name for both monitor and driver

    `uvm_object_utils_begin({{className}}_xagent_config)
        `uvm_field_enum(uvm_active_passive_enum, is_active, UVM_DEFAULT)
        `uvm_field_string(channel_name, UVM_DEFAULT)
    `uvm_object_utils_end

    function new(string name = "{{className}}_xagent_config");
        super.new(name);
        this.channel_name = "{{className}}";
    endfunction
endclass

class {{className}}_xagent extends uvm_agent;
    `uvm_component_utils({{className}}_xagent)

    {{className}}_xagent_config cfg;
    {{className}}_xmonitor {{className}}_xmon;
    {{className}}_xdriver {{className}}_xdrv;

    function new(string name, uvm_component parent = null);
        super.new(name,parent);
        if (!uvm_config_db#({{className}}_xagent_config)::get(this, "", "{{className}}_xagent_config", cfg))
            `uvm_fatal("CFGERR", "Could not get xagent_config")

        // Set is_active for monitor (always exists, just needs to know mode for potential internal logic)
        uvm_config_db#(uvm_active_passive_enum)::set(this, "*", "{{className}}_exist_xmonitor", cfg.is_active);
    endfunction

    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        // Monitor always created (both ACTIVE and PASSIVE modes have monitors)
        {{className}}_xmon = {{className}}_xmonitor::type_id::create($sformatf("%s_sub", cfg.channel_name), this);

        // Driver only created in ACTIVE mode
        if(cfg.is_active == UVM_ACTIVE) begin
            {{className}}_xdrv = {{className}}_xdriver::type_id::create($sformatf("%s.pub", cfg.channel_name), this);
        end
    endfunction

    // Standard UVM connect_phase for TLM connections
    function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);

        // Monitor TLM connection (always present)
        uvmc_tlm #()::connect({{className}}_xmon.out, $sformatf("%s.sub", cfg.channel_name));

        // Driver TLM connection (only in ACTIVE mode)
        if(cfg.is_active == UVM_ACTIVE) begin
            uvmc_tlm #()::connect({{className}}_xdrv.in, $sformatf("%s.pub", cfg.channel_name));
        end
    endfunction

endclass
{% endif -%}
